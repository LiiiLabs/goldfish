<TMU|<tuple|1.0.3|1.2.9.1>>

<style|<tuple|book|chinese|literate|goldfish|reduced-margins>>

<\body>
  <\hide-preamble>
    <assign|scm|<macro|body|<goldfish-lang|<arg|body>>>>

    <assign|scm-chunk|<\macro|name|prev|next|body>
      <\generic-chunk|<arg|name>|<arg|prev>|<arg|next>>
        <with|mode|prog|prog-language|goldfish|font-family|rm|<arg|body>>
      </generic-chunk>
    </macro>>

    <assign|subparagraph|<macro|title|<assign|subparagraph-numbered|<compound|subparagraph-display-numbers>><assign|subparagraph-prefix|<macro|<compound|the-subparagraph>.>><compound|next-subparagraph><compound|subparagraph-clean><compound|subparagraph-header|<arg|title>><compound|subparagraph-toc|<arg|title>><small|<if|<value|subparagraph-numbered>|<compound|subparagraph-numbered-title|<arg|title>>|<compound|subparagraph-unnumbered-title|<arg|title>>>>>>
  </hide-preamble>

  文档许可证暂时没有确定！

  \;

  <chapter|(liii error)>

  异常的命名参考Python标准库的<hlink|内置异常|https://docs.python.org/3/library/exceptions.html>。

  <section|许可证>

  <\scm-chunk|goldfish/liii/error.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    ; see https://docs.python.org/3/library/exceptions.html#exception-hierarchy

    (define-library (liii error)

    (export ???

    \ \ os-error file-not-found-error not-a-directory-error file-exists-error

    \ \ timeout-error

    \ \ type-error value-error)

    (begin

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii error))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|实现>

  <paragraph|os-error><index|os-error>

  系统级别的错误。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (os-error . args)

    \ \ (apply error (cons 'os-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'os-error (os-error))

    \;
  </scm-chunk>

  <paragraph|file-not-found-error><index|file-not-found-error>

  文件未找到。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (file-not-found-error . args)

    \ \ (apply error (cons 'file-not-found-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'file-not-found-error (file-not-found-error))

    \;
  </scm-chunk>

  <paragraph|not-a-directory-error><index|not-a-directory-error>

  不是一个目录。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (not-a-directory-error . args)

    \ \ (apply error (cons 'not-a-directory-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'not-a-directory-error (not-a-directory-error))

    \;
  </scm-chunk>

  <paragraph|file-exists-error><index|file-exists-error>

  文件已存在。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (file-exists-error . args)

    \ \ (apply error (cons 'file-exists-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'file-exists-error (file-exists-error))

    \;
  </scm-chunk>

  <paragraph|timeout-error><index|timeout-error>

  超时错误。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (timeout-error . args)

    \ \ (apply error (cons 'timeout-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'timeout-error (timeout-error))

    \;
  </scm-chunk>

  <paragraph|type-error><index|type-error>

  如果类型不匹配，直接报错。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (type-error . args)

    \ \ (apply error (cons 'type-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'type-error (type-error))

    (check-catch 'type-error (type-error "msg"))

    (check-catch 'type-error (type-error "msg" "msg2"))

    \;
  </scm-chunk>

  <paragraph|value-error><index|value-error>

  值不正确

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (value-error . args)

    \ \ (apply error (cons 'value-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'value-error (value-error))

    \;
  </scm-chunk>

  <paragraph|???><index|???>

  Scala风格未实现错误，一般用于标记为实现的接口。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (???)

    \ \ (error 'not-implemented-error "???"))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'not-implemented-error (???))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/error.scm|true|false>
    ) ; begin

    ) ; define-library

    \;
  </scm-chunk>

  \;

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii list)>

  <section|许可证>

  <\scm-chunk|goldfish/liii/list.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|false|true>
    ;;; SRFI-1 list-processing library \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -*- Scheme -*-

    ;;; Reference implementation

    ;;;

    ;;; SPDX-License-Identifier: MIT

    ;;;

    ;;; Copyright (c) 1998, 1999 by Olin Shivers. You may do as you please with

    ;;; this code as long as you do not remove this copyright notice or

    ;;; hold me liable for its use. Please send bug reports to shivers@ai.mit.edu.

    ;;; \ \ \ \ -Olin

    ;;;

    ;;; Copyright (c) 2024 The Goldfish Scheme Authors

    ;;; Follow the same License as the original one

    \;
  </scm-chunk>

  <section|接口>

  Liii List函数库是金鱼标准库中的List函数库，其中的大部分函数来自函数库<scm|(srfi srfi-1)>，小部分是三鲤自己设计的函数。来自SRFI 1的，我们只是在Liii List中导出相关函数名，相关实现和单元测试都在SRFI 1中维护。

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define-library (liii list)

    (export

    \ \ ; SRFI 1: Constructors

    \ \ circular-list iota

    \ \ ; SRFI 1: Predicates

    \ \ null-list? circular-list?

    \ \ ; SRFI 1: Selectors

    \ \ first second third fourth fifth sixth seventh eighth ninth tenth

    \ \ take drop take-right drop-right

    \ \ last-pair last

    \ \ ; SRFI 1: fold, unfold & map

    \ \ count fold fold-right reduce reduce-right

    \ \ filter partition remove

    \ \ ; SRFI 1: Searching

    \ \ find any every list-index

    \ \ take-while drop-while

    \ \ ; SRFI 1: deleting

    \ \ delete

    \ \ ; Liii List extensions

    \ \ list-view flatmap

    \ \ list-null? list-not-null? not-null-list?

    \ \ length=?

    )

    (import (srfi srfi-1)

    \ \ \ \ \ \ \ \ (liii error))

    (begin

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define-library (srfi srfi-1)

    (export

    \ \ circular-list iota circular-list? null-list?

    \ \ first second third fourth fifth

    \ \ sixth seventh eighth ninth tenth

    \ \ take drop take-right drop-right count fold fold-right

    \ \ reduce reduce-right filter partition remove find

    \ \ delete delete-duplicates

    \ \ take-while drop-while list-index any every

    \ \ last-pair last)

    (begin

    \;
  </scm-chunk>

  <section|测试>

  在金鱼Scheme中的SRFI 1实现需要遵循最小依赖原则，目前<scm|delete-duplicates>是一个复杂度比较高的实现，在SRFI 1中保留，但并不在<scm|(liii list)>导出，故而在本测试文件的开头需要从<scm|(srfi srfi-1)>单独导入。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (import (liii list)

    \ \ \ \ \ \ \ \ (liii check)

    \ \ \ \ \ \ \ \ (only (srfi srfi-1) delete-duplicates))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|SRFI-1>

  SRFI-1中有一部分函数已经在R7RS的<scm|(scheme base)>库里面了。本节不包含R7RS定义的那些函数。

  <subsection|构造器>

  <paragraph|circular-list><index|circular-list>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    ; 0 clause BSD, from S7 repo stuff.scm

    (define circular-list

    \ \ (lambda objs

    \ \ \ \ (let ((lst (copy objs)))

    \ \ \ \ \ \ (set-cdr! (list-tail lst (- (length lst) 1)) lst))))

    \;
  </scm-chunk>

  <paragraph|iota><index|iota>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    ; 0 clause BSD, from S7 repo stuff.scm

    (define* (iota n (start 0) (incr 1))\ 

    \ \ (if (or (not (integer? n)) (\<less\> n 0))

    \ \ \ \ (error 'wrong-type-arg

    \ \ \ \ \ \ \ \ \ \ \ "iota length ~A should be a non-negative integer" n))

    \ \ (let ((lst (make-list n)))

    \ \ \ \ (do ((p lst (cdr p))

    \ \ \ \ \ \ \ \ \ (i start (+ i incr)))

    \ \ \ \ \ \ ((null? p) lst)

    \ \ \ \ \ \ (set! (car p) i))))

    \;
  </scm-chunk>

  测试用例

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (iota 3) =\<gtr\> (list 0 1 2))

    (check (iota 3 7) =\<gtr\> (list 7 8 9))

    (check (iota 2 7 2) =\<gtr\> (list 7 9))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (iota -1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <subsection|谓词>

  <paragraph|circular-list?><index|circular-list?>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    ; 0 clause BSD, from S7 repo stuff.scm

    (define circular-list?

    \ \ (lambda (obj)

    \ \ \ \ (catch #t

    \ \ \ \ \ \ (lambda () (infinite? (length obj)))

    \ \ \ \ \ \ (lambda args #f))))

    \;
  </scm-chunk>

  <todo|在Windows上CI的结果是#f，需要修复这个问题>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    ; (check (circular-list? (circular-list 1 2)) =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|null-list?><index|null-list?>

  <scm|null-list?>是一个函数，返回<scm|#t>当且仅当参数是空列表。当参数为空列表，返回<scm|#t>；否则报错。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (null-list? l)

    \ \ (cond ((pair? l) #f)

    \ \ \ \ \ \ \ \ ((null? l) #t)

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (error 'wrong-type-arg "null-list?: argument out of domain" l))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (null-list? '()) =\<gtr\> #t)

    \;
  </scm-chunk>

  当参数为序对，返回<scm|#f>。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (null-list? '(1 . 2)) =\<gtr\> #f)

    \;
  </scm-chunk>

  当参数为非空列表，返回<scm|#f>。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (null-list? '(1 2)) =\<gtr\> #f)

    \;
  </scm-chunk>

  当参数既不是序对也不是列表，报错。

  辨析：<scm|null?>在参数为非序对时，不报错，只是返回<scm|#f>。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (null? 1) =\<gtr\> #f)

    \;
  </scm-chunk>

  如果已经确定需要判别的对象是列表，使用<scm|null-list?>更加合适。<scm|null?>无法分辨非空的序对和非空的列表，命名上偏模糊，不推荐使用。

  <subsection|选择器>

  <paragraph|first><index|first>

  <scm|first>是一个函数，<scm|car>的同义词，用于返回列表的第1个元素。当列表元素不足1个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (first '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 1)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (first '()))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define first car)

    \;
  </scm-chunk>

  <paragraph|second><index|second>

  <scm|second>是一个函数，<scm|cadr>的同义词，用于返回列表的第2个元素。当列表元素不足2个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (second '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 2)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (second '(1)))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define second cadr)

    \;
  </scm-chunk>

  <paragraph|third><index|third>

  <scm|third>是一个函数，<scm|caddr>的同义词，用于返回列表的第3个元素。当列表元素不足3个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (third '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 3)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (third '(1 2)))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define third caddr)

    \;
  </scm-chunk>

  <paragraph|fourth><index|fourth>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (fourth x) (list-ref x 3))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fourth '(1 2 3 4 5 6)) =\<gtr\> 4)

    \;
  </scm-chunk>

  <paragraph|fifth><index|fifth>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (fifth x) (list-ref x 4))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fifth '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 5)

    \;
  </scm-chunk>

  <paragraph|sixth><index|sixth>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (sixth x) (list-ref x 5))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (sixth '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 6)

    \;
  </scm-chunk>

  <paragraph|seventh><index|seventh>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (seventh x) (list-ref x 6))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (seventh '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 7)

    \;
  </scm-chunk>

  <paragraph|eighth><index|eighth>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (eighth x) (list-ref x 7))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (eighth '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 8)

    \;
  </scm-chunk>

  <paragraph|ninth><index|ninth>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (ninth x) (list-ref x 8))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (ninth '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 9)

    \;
  </scm-chunk>

  <paragraph|tenth><index|tenth>

  <scm|tenth>是一个函数，用于返回列表的第10个元素。当列表元素不足10个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (tenth '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 10)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (tenth x)\ 

    \ \ (cadr (cddddr (cddddr x))))

    \;
  </scm-chunk>

  <paragraph|take><index|take>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (take '(1 2 3 4) 3) =\<gtr\> '(1 2 3))

    \;

    (check (take '(1 2 3 4) 4) =\<gtr\> '(1 2 3 4))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (take '(1 2 3 4) 5))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;

    (check (take '(1 2 3 . 4) 3) =\<gtr\> '(1 2 3))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (take '(1 2 3 . 4) 4))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <scm|take>是一个函数，接收一个列表和一个非负整数k为参数，返回列表的前k个元素组成的新列表。当列表元素数量不足k个，报错。

  <\session|goldfish|default>
    <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
      (define (take l k)

      \ \ (let recur ((l l) (k k))

      \ \ \ \ (if (zero? k) '()

      \ \ \ \ \ \ \ \ (cons (car l)

      \ \ \ \ \ \ \ \ \ \ \ \ \ \ (recur (cdr l) (- k 1))))))

      \;
    </scm-chunk>
  </session>

  <paragraph|drop><index|drop>

  <scm|drop>是一个函数，接收一个列表和一个非负整数k为参数，返回去掉列表前k个元素组成的新列表。当列表元素数量不足k个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (drop '(1 2 3 4) 2) =\<gtr\> '(3 4))

    \;

    (check (drop '(1 2 3 4) 4) =\<gtr\> '())

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (drop '(1 2 3 4) 5))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;

    (check (drop '(1 2 3 . 4) 3) =\<gtr\> 4)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (drop '(1 2 3 . 4) 4))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <\session|goldfish|default>
    \;

    <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
      (define (drop l k)

      \ \ (let iter ((l l) (k k))

      \ \ \ \ (if (zero? k) l (iter (cdr l) (- k 1)))))

      \;
    </scm-chunk>
  </session>

  <paragraph|take-right><index|take-right>

  <scm|take-right>是一个函数，接收一个列表和一个非负整数k为参数，取出列表的后k个元素组成新列表，返回这个新列表。当列表元素数量不足k个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (take-right '(1 2 3 4) 3) =\<gtr\> '(2 3 4))

    \;

    (check (take-right '(1 2 3 4) 4) =\<gtr\> '(1 2 3 4))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (take-right '(1 2 3 4) 5))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;

    (check (take-right '(1 2 3 . 4) 3) =\<gtr\> '(1 2 3 . 4))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (take-right '(1 2 3 . 4) 4))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (take-right l k)

    \ \ (let lp ((lag l) \ (lead (drop l k)))

    \ \ \ \ (if (pair? lead)

    \ \ \ \ \ \ \ \ (lp (cdr lag) (cdr lead))

    \ \ \ \ \ \ \ \ lag)))

    \;
  </scm-chunk>

  <paragraph|drop-right><index|drop-right>

  <scm|drop-right>是一个函数，接收一个列表和一个非负整数k为参数，去掉列表的后k个元素组成新列表，返回这个新列表。当列表元素数量不足k个，报错。当k为负数，报错。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (drop-right l k)

    \ \ (let recur ((lag l) (lead (drop l k)))

    \ \ \ \ (if (pair? lead)

    \ \ \ \ \ \ \ \ (cons (car lag) (recur (cdr lag) (cdr lead)))

    \ \ \ \ \ \ \ \ '())))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (drop-right '(1 2 3 4) 2) =\<gtr\> '(1 2))

    \;

    (check (drop-right '(1 2 3 4) 4) =\<gtr\> '())

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (drop-right '(1 2 3 4) 5))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (drop-right '(1 2 3 4) -1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;

    (check (drop-right '(1 2 3 . 4) 3) =\<gtr\> '())

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (drop-right '(1 2 3 . 4) 4))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|last-pair><index|last-pair>

  <scm|last-pair>是一个函数，以序对形式返回列表的最后一个元素，参数必须是序对，空列表报错。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (last-pair l)

    \ \ (if (pair? (cdr l))

    \ \ \ \ \ \ (last-pair (cdr l)) l))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (last-pair '(a b c)) =\<gtr\> '(c))

    (check (last-pair '(c)) =\<gtr\> '(c))

    \;

    (check (last-pair '(a b . c)) =\<gtr\> '(b . c))

    (check (last-pair '(b . c)) =\<gtr\> '(b . c))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (last-pair '()))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|last><index|last>

  <scm|last>是一个函数，以符号形式返回列表的最后一个元素，参数必须是序对，空列表报错。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (last l)

    \ \ (car (last-pair l)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (last '(a b c)) =\<gtr\> 'c)

    (check (last '(c)) =\<gtr\> 'c)

    \;

    (check (last '(a b . c)) =\<gtr\> 'b)

    (check (last '(b . c)) =\<gtr\> 'b)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (last '()))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <subsection|常用函数>

  <paragraph|count><index|count>

  <scm|count>是一个高阶函数，它接收两个参数：一个谓词和一个列表；返回满足谓词条件的元素在列表中出现的次数。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (count pred list1 . lists)

    \ \ (let lp ((lis list1) (i 0))

    \ \ \ \ (if (null-list? lis) i

    \ \ \ \ \ \ \ \ (lp (cdr lis) (if (pred (car lis)) (+ i 1) i)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (count even? '(3 1 4 1 5 9 2 5 6)) =\<gtr\> 3)

    \;
  </scm-chunk>

  <subsection|折叠和映射>

  <paragraph|fold><index|fold>

  <scm|fold>是一个高阶函数，它接受三个参数：一个函数、一个初始值和一个列表，将函数累积地应用到一个列表的所有元素上，从左到右，从而将列表折叠成一个单一的值。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (fold f initial l)

    \ \ (when (not (procedure? f))

    \ \ \ \ (error 'type-error "The first param must be a procedure"))

    \ \ (if (null? l)

    \ \ \ \ \ \ initial

    \ \ \ \ \ \ (fold f

    \ \ \ \ \ \ \ \ \ \ \ \ (f (car l) initial)

    \ \ \ \ \ \ \ \ \ \ \ \ (cdr l))))

    \;
  </scm-chunk>

  这是SRFI-1官方提供的实现，我们暂时不用。

  <\scm-code>
    (define (fold kons knil lis1 . lists)

    \ \ (if (pair? lists)

    \ \ \ \ \ \ (let lp ((lists (cons lis1 lists)) (ans knil))

    \ \ \ \ \ \ \ \ (receive (cars+ans cdrs) (%cars+cdrs+ lists ans)

    \ \ \ \ \ \ \ \ \ \ (if (null? cars+ans) ans

    \ \ \ \ \ \ \ \ \ \ \ \ \ (lp cdrs (apply kons cars+ans)))))

    \;

    \ \ \ \ \ \ (let lp ((lis lis1) (ans knil))

    \ \ \ \ \ \ \ \ (if (null-list? lis) ans

    \ \ \ \ \ \ \ \ \ \ \ \ (lp (cdr lis) (kons (car lis) ans))))))
  </scm-code>

  常见的用法：

  从初始值开始，依次累加列表中的元素，返回一个数；当列表为空列表时，返回初始值。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fold + 0 '(1 2 3 4)) =\<gtr\> 10)

    \;

    (check (fold + 0 '()) =\<gtr\> 0)

    \;

    (check-catch 'type-error (fold 0 + '(1 2 3 4)))

    \;
  </scm-chunk>

  反转列表中的元素，返回一个新列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fold cons () '(1 2 3 4)) =\<gtr\> '(4 3 2 1))

    \;
  </scm-chunk>

  统计列表中满足谓词的元素数量，返回这个数量。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (fold (lambda (x count) (if (symbol? x) (+ count 1) count))

    \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ '(a b 1 2 3 4))

    \ \ =\<gtr\> 2)

    \;
  </scm-chunk>

  <paragraph|fold-right><index|fold-right>

  <scm|fold-right>与<scm|fold>类似，不同的是，<scm|fold-right>是从右到左折叠。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (fold-right f initial l)

    \ \ (if (null? l)

    \ \ \ \ initial

    \ \ \ \ (f (car l)

    \ \ \ \ \ \ \ \ (fold-right f

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ initial

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cdr l)))))

    \;
  </scm-chunk>

  这是SRFI-1官方提供的实现，我们暂时不用：

  <\scm-code>
    (define (fold-right kons knil lis1 . lists)

    \ \ (if (pair? lists)

    \ \ \ \ \ \ (let recur ((lists (cons lis1 lists)))

    \ \ \ \ \ \ \ \ (let ((cdrs (%cdrs lists)))

    \ \ \ \ \ \ \ \ \ \ (if (null? cdrs) knil

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (apply kons (%cars+ lists (recur cdrs))))))

    \;

    \ \ \ \ \ \ (let recur ((lis lis1))

    \ \ \ \ \ \ \ \ (if (null-list? lis) knil

    \ \ \ \ \ \ \ \ \ \ \ \ (let ((head (car lis)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (kons head (recur (cdr lis))))))))
  </scm-code>

  在用作累加、统计时，<scm|fold-right>与<scm|fold>的结果是相同的。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fold-right + 0 '(1 2 3 4)) =\<gtr\> 10)

    \;

    (check (fold-right + 0 '()) =\<gtr\> 0)

    \;

    (check

    \ \ (fold-right (lambda (x count) (if (symbol? x) (+ count 1) count))

    \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ '(a b 1 2 3 4))

    \ \ =\<gtr\>

    \ \ 2)

    \;
  </scm-chunk>

  但<scm|fold-right>与<scm|fold>的折叠方向是相反的，这就使得列表原本的顺序得以保持，不会反转。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fold-right cons () '(1 2 3 4)) =\<gtr\> '(1 2 3 4))

    \;
  </scm-chunk>

  <paragraph|reduce><index|reduce>

  <scm|reduce>与<scm|fold>类似，但有微妙且关键的不同。只有在列表为空列表时，才会使用这个初始值。在列表不是空列表时，则把列表的<scm|\<less\>car\<gtr\>>部分取出作为<scm|fold>的初始值，又把列表的<scm|\<less\>cdr\<gtr\>>部分取出作为<scm|fold>的列表。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (reduce f initial l)

    \ \ (if (null-list? l) initial

    \ \ \ \ \ \ (fold f (car l) (cdr l))))

    \;
  </scm-chunk>

  在用作累加时，<scm|reduce>与<scm|fold>的结果是相同的。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (reduce + 0 '(1 2 3 4)) =\<gtr\> 10)

    \;

    (check (reduce + 0 '()) =\<gtr\> 0)

    \;
  </scm-chunk>

  不适用于反转列表中的元素，但当列表非空，返回的不再是列表，而是序对。因为<scm|reduce>会把非空列表的第一个元素取出来作为<scm|fold>的初始值。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (reduce cons () '(1 2 3 4)) =\<gtr\> '(4 3 2 . 1))

    \;
  </scm-chunk>

  不适用于统计列表中满足谓词的元素数量，因为<scm|reduce>会把非空列表的第一个元素取出来作为<scm|fold>的初始值，引发错误。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda

    \ \ \ \ \ \ ()

    \ \ \ \ \ \ (reduce (lambda (x count) (if (symbol? x) (+ count 1) count))

    \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ '(a b 1 2 3 4)))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <paragraph|reduce-right><index|reduce-right>

  <scm|reduce-right>与<scm|reduce>类似，不同的是，<scm|reduce-right>是从右到左规约。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (reduce-right f initial l)

    \ \ (if (null-list? l) initial

    \ \ \ \ \ \ (let recur ((head (car l)) (l (cdr l)))

    \ \ \ \ \ \ \ \ (if (pair? l)

    \ \ \ \ \ \ \ \ \ \ \ \ (f head (recur (car l) (cdr l)))

    \ \ \ \ \ \ \ \ \ \ \ \ head))))

    \;
  </scm-chunk>

  在用作累加时，<scm|reduce-right>与<scm|fold>的结果是相同的。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (reduce-right + 0 '(1 2 3 4)) =\<gtr\> 10)

    \;

    (check (reduce-right + 0 '()) =\<gtr\> 0)

    \;
  </scm-chunk>

  也不适用于重列列表中的元素，以及统计列表中满足谓词的元素数量。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (reduce-right cons () '(1 2 3 4))

    \ \ \ \ \ \ \ =\<gtr\> '(1 2 3 . 4) )

    \;

    (check

    \ \ (reduce-right (lambda (x count) (if (symbol? x) (+ count 1) count))

    \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ '(a b 1 2 3 4))

    \ \ =\<gtr\> 6)

    \;
  </scm-chunk>

  <subsection|过滤和分组>

  <paragraph|filter><index|filter>

  <scm|filter>是一个高阶函数，接收一个谓词和一个列表为参数，从这个列表中筛出满足谓词的元素，组成一个新列表，返回这个新列表。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (filter pred l)

    \ \ (let recur ((l l))

    \ \ \ \ (if (null-list? l) l

    \ \ \ \ \ \ \ \ (let ((head (car l))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (tail (cdr l)))

    \ \ \ \ \ \ \ \ \ \ (if (pred head)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let ((new-tail (recur tail)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (eq? tail new-tail) l

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons head new-tail)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (recur tail))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (filter even? '(-2 -1 0 1 2)) =\<gtr\> '(-2 0 2))

    \;
  </scm-chunk>

  <paragraph|partition><index|partition>

  <scm|partition>是一个高阶函数，接收一个谓词和一个列表为参数，从这个列表中分别筛出满足和不满足谓词的元素，各组成一个新列表，返回以这两个新列表组成的序对。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (partition pred l)

    \ \ (let loop ((lst l) (satisfies '()) (dissatisfies '()))

    \ \ \ \ (cond ((null? lst)

    \ \ \ \ \ \ \ \ \ \ \ (cons satisfies dissatisfies))

    \ \ \ \ \ \ \ \ \ \ ((pred (car lst))

    \ \ \ \ \ \ \ \ \ \ \ (loop (cdr lst) (cons (car lst) satisfies) dissatisfies))

    \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ (loop (cdr lst) satisfies (cons (car lst) dissatisfies))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (partition symbol? '(one 2 3 four five 6))

    \ \ =\<gtr\> (cons '(five four one) '(6 3 2)))

    \;
  </scm-chunk>

  <paragraph|remove><index|remove>

  <scm|remove>是一个高阶函数，接收一个谓词和一个列表为参数，从这个列表中去掉满足谓词的元素，组成一个新列表，返回这个新列表。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (remove pred l)

    \ \ (filter (lambda (x) (not (pred x))) l))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (remove even? '(-2 -1 0 1 2)) =\<gtr\> '(-1 1))

    \;
  </scm-chunk>

  <subsection|搜索>

  <paragraph|find><index|find>

  <scm|find>是一个高阶函数，接收一个谓词和一个列表为参数，返回该列表中第一个满足谓词的元素。当列表为空列表，或列表中没有满足谓词的元素，返回<scm|#f>。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (find pred l)

    \ \ (cond ((null? l) #f)

    \ \ \ \ \ \ \ \ ((pred (car l)) (car l))\ 

    \ \ \ \ \ \ \ \ (else (find pred (cdr l)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (find even? '(3 1 4 1 5 9)) =\<gtr\> 4)

    \;

    (check (find even? '()) =\<gtr\> #f)

    \;

    (check (find even? '(1 3 5 7 9)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|take-while><index|take-while>

  <scm|take-while>是一个高阶函数，接收一个谓词和一个列表为参数，按列表顺序筛出满足谓词的元素，直到不满足谓词的那个一个就停止筛选，返回筛出的元素组成的列表。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (take-while pred lst)

    \ \ (if (null? lst)\ 

    \ \ \ \ \ \ '()

    \ \ \ \ \ \ (if (pred (car lst))

    \ \ \ \ \ \ \ \ \ \ (cons (car lst) (take-while pred (cdr lst)))

    \ \ \ \ \ \ \ \ \ \ '())))

    \;
  </scm-chunk>

  当参数的列表为空列表，无论谓词是什么都返回空列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check <code*|(take-while even? '())> =\<gtr\> '())

    \;
  </scm-chunk>

  当列表中所有元素都满足谓词，返回原列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (take-while (lambda (x) #t) '(1 2 3))

    \ \ =\<gtr\> '(1 2 3))

    \;
  </scm-chunk>

  当列表中没有元素满足谓词，返回空列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (take-while (lambda (x) #f) '(1 2 3))

    \ \ =\<gtr\> '())

    \;
  </scm-chunk>

  当列表的第一个元素就不满足谓词，返回空列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (take-while (lambda (x) (not (= x 1))) '(1 2 3))

    \ \ =\<gtr\> '())

    \;
  </scm-chunk>

  筛出元素的过程按照列表的顺序进行，当一个元素已经不满足谓词，那么这个元素之后的元素不会被筛出。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (take-while (lambda (x) (\<less\> x 3)) '(1 2 3 0))

    \ \ =\<gtr\> '(1 2))

    \;
  </scm-chunk>

  <paragraph|drop-while><index|drop-while>

  <scm|drop-while>是一个高阶函数，接收一个谓词和一个列表为参数，按列表顺序丢掉满足谓词的元素，直到不满足谓词的那个一个就停止丢掉，返回剩下的元素组成的列表。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (drop-while pred l)

    \ \ (if (null? l)

    \ \ \ \ \ \ '()

    \ \ \ \ \ \ (if (pred (car l))

    \ \ \ \ \ \ \ \ \ \ (drop-while pred (cdr l))

    \ \ \ \ \ \ \ \ \ \ l)))

    \;
  </scm-chunk>

  当列表为空列表，返回空列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (drop-while even? '()) =\<gtr\> '())

    \;
  </scm-chunk>

  当列表中所有元素都满足谓词，返回空列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (drop-while (lambda (x) #t) '(1 2 3)) =\<gtr\> '())

    \;
  </scm-chunk>

  当列表中没有元素满足谓词，返回原列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (drop-while (lambda (x) #f) '(1 2 3)) =\<gtr\> '(1 2 3))

    \;
  </scm-chunk>

  当列表的第一个元素就不满足谓词，返回原列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (drop-while (lambda (x) (not (= x 1))) '(1 2 3))

    \ \ =\<gtr\> '(1 2 3))

    \;
  </scm-chunk>

  <paragraph|list-index><index|list-index>

  <scm|list-index>是一个高阶函数，接收一个谓词和一个列表为参数，返回第一个符合谓词要求的元素的位置索引。当列表为空列表，或列表中没有满足谓词的元素，返回<scm|#f>。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (list-index pred l)

    \ \ \ \ (let loop ((index 0) (l l))

    \ \ \ \ \ \ (if (null? l)

    \ \ \ \ \ \ \ \ \ \ #f

    \ \ \ \ \ \ \ \ \ \ (if (pred (car l))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ index

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ index 1) (cdr l))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (list-index even? '(3 1 4 1 5 9)) =\<gtr\> 2)

    (check (list-index even? '()) =\<gtr\> #f)

    (check (list-index even? '(1 3 5 7 9)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|any><index|any>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (any pred? l)

    \ \ (cond ((null? l) #f)

    \ \ \ \ \ \ \ \ ((pred? (car l)) #t)

    \ \ \ \ \ \ \ \ (else (any pred? (cdr l)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (any integer? '()) =\<gtr\> #f)

    (check (any integer? '(a 3.14 "3")) =\<gtr\> #f)

    (check (any integer? '(a 3.14 3)) =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|every><index|every>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (every pred? l)

    \ \ (cond ((null? l) #t)

    \ \ \ \ \ \ \ \ ((not (pred? (car l))) #f)

    \ \ \ \ \ \ \ \ (else (every pred? (cdr l)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (every integer? '()) =\<gtr\> #t)

    (check (every integer? '(a 3.14 3)) =\<gtr\> #f)

    (check (every integer? '(1 2 3)) =\<gtr\> #t)

    \;
  </scm-chunk>

  <subsection|删除>

  公共子函数，用于处理可选的<scm|maybe-equal>参数。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (%extract-maybe-equal maybe-equal)

    \ \ (let ((my-equal (if (null-list? maybe-equal)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car maybe-equal))))

    \ \ \ \ (if (procedure? my-equal)

    \ \ \ \ \ \ \ \ my-equal

    \ \ \ \ \ \ \ \ (error 'wrong-type-arg "maybe-equal must be procedure"))))
  </scm-chunk>

  <paragraph|delete><index|delete>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (delete x l . maybe-equal)

    \ \ (let ((my-equal (%extract-maybe-equal maybe-equal)))

    \ \ \ \ (filter (lambda (y) (not (my-equal x y))) l)))

    \;
  </scm-chunk>

  测试用例

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (delete 1 (list 1 2 3 4)) =\<gtr\> (list 2 3 4))

    \;

    (check (delete 0 (list 1 2 3 4)) =\<gtr\> (list 1 2 3 4))

    \;

    (check (delete #\\a (list #\\a #\\b #\\c) char=?)

    \ \ \ \ \ \ \ =\<gtr\> (list #\\b #\\c))

    \;

    (check (delete #\\a (list #\\a #\\b #\\c) (lambda (x y) #f))

    \ \ \ \ \ \ \ =\<gtr\> (list #\\a #\\b #\\c))

    \;

    (check (delete 1 (list )) =\<gtr\> (list ))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda ()

    \ \ \ \ \ \ (check (delete 1 (list 1 2 3 4) 'not-pred) =\<gtr\> 1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|delete-duplicates><index|delete-duplicates>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    ;;; right-duplicate deletion

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;; delete-duplicates delete-duplicates!

    ;;;

    ;;; Beware -- these are N^2 algorithms. To efficiently remove duplicates

    ;;; in long lists, sort the list to bring duplicates together, then use a

    ;;; linear-time algorithm to kill the dups. Or use an algorithm based on

    ;;; element-marking. The former gives you O(n lg n), the latter is linear.

    \;

    (define (delete-duplicates lis . maybe-equal)

    \ \ (let ((my-equal (%extract-maybe-equal maybe-equal)))

    \ \ \ \ (let recur ((lis lis))

    \ \ \ \ \ \ (if (null-list? lis)

    \ \ \ \ \ \ \ \ \ \ lis

    \ \ \ \ \ \ \ \ \ \ (let* ((x (car lis))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (tail (cdr lis))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (new-tail (recur (delete x tail my-equal))))

    \ \ \ \ \ \ \ \ \ \ \ \ (if (eq? tail new-tail)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lis

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons x new-tail)))))))

    \;
  </scm-chunk>

  测试用例

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (delete-duplicates (list 1 1 2 3)) =\<gtr\> (list 1 2 3))

    (check (delete-duplicates (list 1 2 3)) =\<gtr\> (list 1 2 3))

    (check (delete-duplicates (list 1 1 1)) =\<gtr\> (list 1))

    \;

    (check (delete-duplicates (list )) =\<gtr\> (list ))

    \;

    (check (delete-duplicates (list 1 1 2 3) (lambda (x y) #f))

    \ \ \ \ \ \ \ =\<gtr\> (list 1 1 2 3))

    \;
  </scm-chunk>

  如果判断相等的函数类型不正确，会报错：

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda

    \ \ \ \ \ \ ()

    \ \ \ \ \ \ (check (delete-duplicates (list 1 1 2 3) 'not-pred) =\<gtr\> 1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <section|三鲤扩展库>

  <paragraph|length=?><index|length=?><scm|(x l) =\<gtr\> boolean>

  <\description>
    <item*|x>期望的列表长度，如果长度为负数，该函数会抛出<scm|value-error>

    <item*|l>列表
  </description>

  快速判断一个列表<scm|l>的长度是否为<scm|x>。由于<scm|(= x (length l))>这种判断方式的复杂度是<math|O<around*|(|n|)>>，故而需要<scm|length=?>这种快速的判断方式。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check-true (length=? 3 (list 1 2 3)))

    (check-false (length=? 2 (list 1 2 3)))

    (check-false (length=? 4 (list 1 2 3)))

    \;

    (check-true (length=? 0 (list )))

    (check-catch 'value-error (length=? -1 (list )))

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (length=? x scheme-list)

    \ \ (when (\<less\> x 0)

    \ \ \ \ (value-error "length=?: expected non-negative integer x but received ~d" x))

    \ \ (cond ((and (= x 0) (null? scheme-list)) #t)

    \ \ \ \ \ \ \ \ ((or (= x 0) (null? scheme-list)) #f)

    \ \ \ \ \ \ \ \ (else (length=? (- x 1) (cdr scheme-list)))))

    \;
  </scm-chunk>

  <paragraph|list-view><index|list-view>

  由于Scheme的List和数据的流向是相反的：

  <\scm-code>
    (map (lambda (x) (* x x))

    \ \ \ \ \ (map (lambda (x) (+ x 1))

    \ \ \ \ \ \ \ \ \ \ (list 1 2 3)))
  </scm-code>

  \;

  所以我们实现了<scm|list-view>，采用和Scala的List类似的语法来处理数据：

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check ((list-view (list 1 2 3))) =\<gtr\> (list 1 2 3))

    \;

    (check (((list-view (list 1 2 3))

    \ \ \ \ \ \ \ \ map (lambda (x) (+ x 1)))) =\<gtr\> (list 2 3 4))

    \;

    (check (((list-view (list 1 2 3))

    \ \ \ \ \ \ \ \ map (lambda (x) (+ x 1))

    \ \ \ \ \ \ \ \ map (lambda (x) (* x x))))

    \ \ \ \ \ \ \ =\<gtr\> (list 4 9 16))

    \;
  </scm-chunk>

  <scm|(list-view 1 2 3)>得到的是函数，需要在外面再加一层括号才能得到<scm|(list 1 2 3)>。

  <\big-figure|<wide-tabular|<tformat|<table|<row|<\cell>
    <\scm-code>
      (map (lambda (x) (* x x))

      \ \ \ \ \ (map (lambda (x) (+ x 1))

      \ \ \ \ \ \ \ \ \ \ (list 1 2 3)))
    </scm-code>
  </cell>|<\cell>
    <\scm-code>
      (((list-view 1 2 3)

      \ \ \ \ \ \ \ \ map (lambda (x) (+ x 1))

      \ \ \ \ \ \ \ \ map (lambda (x) (* x x))))
    </scm-code>
  </cell>>>>>>
    使用list处理数据和使用list-view处理数据的对比
  </big-figure>

  实现list-view时需要考虑三种情况和一种例外情况。

  <\description>
    <item*|无参数>也就是直接在list-view得到的结果外面添加括号，此时得到的是list-view对应的list

    <item*|有两个参数>这里举例说明，<scm|((list-view 1 2 3) map (lambda (x) (+ x 1)))>实际的计算过程是：

    <\enumerate>
      <item>计算并得到结果<scm|(map (lambda (x) (+ x 1)) (list 1 2 3)) =\<gtr\> (list 2 3 4)>

      <item>将计算结果包装到 <scm|list-view> 里面，这里使用了<scm|apply>这个内置函数
    </enumerate>

    其实也是树的转换：

    <\big-figure|<scm|<tree|(list-view 1 2 3)|map|(lambda (x) (+ x 1))>><space|2em><math|\<Rightarrow\>><space|2em><scm|<tree|map|(lambda (x) (+ x 1))|(list 1 2 3)>>>
      原理的可视化
    </big-figure>

    <item*|偶数个参数>在上述两个递归退出条件写好的情况下，在思考这种一般的情况。

    需要计算<scm|((list-view 1 2 3) hf1 f1 hf2 f2 ... hfn fn)>，其中hf指的是high-order function，也就是高阶函数。也就是需要计算：

    <\scm>
      ((((list-view 1 2 3) hf1 f1) hf2 f2) ... hfn fn)
    </scm>

    \;
  </description>

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (list-view scheme-list)

    \ \ (define (f-inner-reducer scheme-list filter filter-func rest-funcs)

    \ \ \ \ (cond ((null? rest-funcs) (list-view (filter filter-func scheme-list)))

    \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ (f-inner-reducer (filter filter-func scheme-list)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car rest-funcs)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cadr rest-funcs)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cddr rest-funcs)))))

    \ \ (define (f-inner . funcs)

    \ \ \ \ (cond ((null? funcs) scheme-list)

    \ \ \ \ \ \ \ \ \ \ ((length=? 2 funcs)

    \ \ \ \ \ \ \ \ \ \ \ (list-view ((car funcs) (cadr funcs) scheme-list)))

    \ \ \ \ \ \ \ \ \ \ ((even? (length funcs))

    \ \ \ \ \ \ \ \ \ \ \ (f-inner-reducer scheme-list

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car funcs)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cadr funcs)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cddr funcs)))

    \ \ \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "list-view only accepts even number of args"))))

    \ \ f-inner)

    \;
  </scm-chunk>

  <paragraph|flatmap><index|flatmap>

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (flatmap f seq)

    \ \ (fold-right append () (map f seq)))

    \;
  </scm-chunk>

  \;

  <paragraph|not-null-list?><index|not-null-list?>

  <scm|null-list?>的反面，会抛出异常。

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (not-null-list? l)

    \ \ (cond ((pair? l)

    \ \ \ \ \ \ \ \ \ (or (null? (cdr l)) (pair? (cdr l))))

    \ \ \ \ \ \ \ \ ((null? l) #f)

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (error 'type-error "type mismatch"))))

    \;
  </scm-chunk>

  <paragraph|list-null?><index|null-list?>

  <scm|null-list?>的没有异常的版本，只要不是<scm|list>，都是<scm|#f>。

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (list-null? l)

    \ \ (and (not (pair? l)) (null? l)))

    \;
  </scm-chunk>

  <paragraph|list-not-null?><index|list-not-null?>

  <scm|not-null-list?>的没有异常的版本。

  \;

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (list-not-null? l)

    \ \ (and (pair? l)

    \ \ \ \ \ \ \ (or (null? (cdr l)) (pair? (cdr l)))))

    \;
  </scm-chunk>

  \;

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (not-null-list? (list 1)) =\<gtr\> #t)

    (check (list-not-null? (list 1)) =\<gtr\> #t)

    (check (list-null? (list 1)) =\<gtr\> #f)

    \;

    (check (not-null-list? (list 1 2 3)) =\<gtr\> #t)

    (check (list-not-null? (list 1 2 3)) =\<gtr\> #t)

    (check (list-null? (list 1 2 3)) =\<gtr\> #f)

    \;

    (check (not-null-list? '(a)) =\<gtr\> #t)

    (check (list-not-null? '(a)) =\<gtr\> #t)

    (check (list-null? '(a)) =\<gtr\> #f)

    \;

    (check (not-null-list? '(a b c)) =\<gtr\> #t)

    (check (list-not-null? '(a b c)) =\<gtr\> #t)

    (check (list-null? '(a b c)) =\<gtr\> #f)

    \;

    (check (not-null-list? ()) =\<gtr\> #f)

    (check (list-not-null? ()) =\<gtr\> #f)

    (check (list-null? ()) =\<gtr\> #t)

    \;

    ; '(a) is a pair and a list

    ; '(a . b) is a pair but not a list

    (check (not-null-list? '(a . b)) =\<gtr\> #f)

    (check (list-not-null? '(a . b)) =\<gtr\> #f)

    (check (list-null? '(a . b)) =\<gtr\> #f)

    \;

    (check-catch 'type-error (not-null-list? 1))

    (check (list-not-null? 1) =\<gtr\> #f)

    (check (list-null? 1) =\<gtr\> #f)

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/list.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii stack)>

  栈是一个先进后出（FILO）的数据结构。

  这个函数库是三鲤自定义的库，参考了C++和Java的栈相关的函数库的接口。

  <section|许可证>

  <\scm-chunk|goldfish/liii/stack.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define-library (liii stack)

    (import (srfi srfi-9)

    \ \ \ \ \ \ \ \ (liii base)

    \ \ \ \ \ \ \ \ (liii error))

    (export

    \ stack

    \ stack? stack-empty?

    \ stack-size stack-top

    \ stack-push! stack-pop!

    \ stack-\<gtr\>list

    )

    (begin

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/stack-test.scm|false|false>
    (import (liii stack)

    \ \ \ \ \ \ \ \ (liii check))

    \;

    (check-set-mode! 'report-failed)

    \;

    (define stack1 (stack))

    (check (stack-empty? stack1) =\<gtr\> #t)

    (check (stack-\<gtr\>list stack1) =\<gtr\> '())

    (check-catch 'value-error (stack-pop! stack1))

    \;

    (stack-push! stack1 1)

    (check (stack-\<gtr\>list stack1) =\<gtr\> '(1))

    (check (stack-top stack1) =\<gtr\> 1)

    (check (stack-size stack1) =\<gtr\> 1)

    (check (stack-pop! stack1) =\<gtr\> 1)

    (check (stack-empty? stack1) =\<gtr\> #t)

    (check (stack-size stack1) =\<gtr\> 0)

    \;

    (define stack2 (stack 1 2 3))

    (check (stack-\<gtr\>list stack2) =\<gtr\> '(1 2 3))

    (check (stack-size stack2) =\<gtr\> 3)

    (check (stack-pop! stack2) =\<gtr\> 1)

    (check (stack-pop! stack2) =\<gtr\> 2)

    (check (stack-pop! stack2) =\<gtr\> 3)

    \;

    (define stack3 (stack ))

    (stack-push! stack3 1)

    (stack-push! stack3 2)

    (stack-push! stack3 3)

    (check (stack-pop! stack3) =\<gtr\> 3)

    (check (stack-pop! stack3) =\<gtr\> 2)

    (check (stack-pop! stack3) =\<gtr\> 1)

    \;

    (check-catch 'type-error (stack-empty? 1))

    \;
  </scm-chunk>

  <section|实现>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define-record-type :stack

    \ \ (make-stack data)

    \ \ stack?

    \ \ (data get-data set-data!))

    \;

    (define (%stack-check-parameter st)

    \ \ (when (not (stack? st))

    \ \ \ \ (error 'type-error "Parameter st is not a stack")))

    \;
  </scm-chunk>

  <paragraph|stack><index|stack><scm|(x1 x2 ...) =\<gtr\> stack>

  传入参数，构造一个栈，第一个参数是栈顶。如果没有参数，则构造的是空栈。

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack . l)

    \ \ (if (null? l)

    \ \ \ \ \ \ (make-stack '())

    \ \ \ \ \ \ (make-stack l)))

    \;
  </scm-chunk>

  <paragraph|stack-empty?><index|stack-empty?><scm|(st) =\<gtr\> bool>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-empty? st)

    \ \ (%stack-check-parameter st)

    \ \ (null? (get-data st)))

    \;
  </scm-chunk>

  <paragraph|stack-size><index|stack-size><scm|(st) =\<gtr\> int>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-size st)

    \ \ (%stack-check-parameter st)

    \ \ (length (get-data st)))

    \;
  </scm-chunk>

  <paragraph|stack-top><index|stack-top><scm|(st) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-top st)

    \ \ (%stack-check-parameter st)

    \ \ (car (get-data st)))

    \;
  </scm-chunk>

  <paragraph|stack-push!><index|stack-push!><scm|(st x) =\<gtr\> #\<less\>unspecified\<gtr\>>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-push! st elem)

    \ \ (%stack-check-parameter st)

    \ \ (set-data! st (cons elem (get-data st))))

    \;
  </scm-chunk>

  <paragraph|stack-pop!><index|stack-pop!><scm|(st) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-pop! st)

    \ \ (%stack-check-parameter st)

    \ \ (when (stack-empty? st)

    \ \ \ \ (error 'value-error "Failed to stack-pop! on empty stack"))

    \ \ (let1 data (get-data st)

    \ \ \ \ (set-data! st (cdr data))

    \ \ \ \ (car data)))

    \;
  </scm-chunk>

  <paragraph|stack-\<gtr\>list><index|stack-\<gtr\>list><scm|(st) =\<gtr\> list>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-\<gtr\>list st)

    \ \ (%stack-check-parameter st)

    \ \ (get-data st))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/stack.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <chapter|(liii queue)>

  这个函数库是三鲤自定义的库，参考了C++和Java的队列相关的函数库的接口。目前基于Scheme的列表实现，从队列取出数据的复杂度是<math|O<around*|(|1|)>>，从队列存入数据的复杂度是<math|O<around*|(|n|)>>。

  <section|许可证>

  <\scm-chunk|goldfish/liii/queue.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/queue-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define-library (liii queue)

    (import (liii list)

    \ \ \ \ \ \ \ \ (liii base)

    \ \ \ \ \ \ \ \ (srfi srfi-9)

    \ \ \ \ \ \ \ \ (liii error))

    (export

    \ \ queue

    \ \ queue? queue-empty?

    \ \ queue-size queue-front queue-back

    \ \ queue-pop! queue-push!

    \ \ queue-\<gtr\>list)

    (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/queue-test.scm|true|true>
    (import (liii queue)

    \ \ \ \ \ \ \ \ (liii base)

    \ \ \ \ \ \ \ \ (liii check))

    \;

    (check-set-mode! 'report-failed)

    \;

    (let1 q1 (queue)

    \ \ (check-true (queue-empty? q1))

    \ \ (check (queue-size q1) =\<gtr\> 0)

    \ \ (check-catch 'value-error (queue-pop! q1))

    \;

    \ \ (queue-push! q1 1)

    \ \ (check (queue-size q1) =\<gtr\> 1)

    \ \ (check (queue-front q1) =\<gtr\> 1)

    \ \ (check (queue-back q1) =\<gtr\> 1)

    \ \ (check (queue-pop! q1) =\<gtr\> 1)

    \ \ (check-true (queue-empty? q1))

    )

    \;

    (let1 q2 (queue 1 2 3)

    \ \ (check (queue-size q2) =\<gtr\> 3)

    \ \ (check (queue-front q2) =\<gtr\> 1)

    \ \ (check (queue-back q2) =\<gtr\> 3)

    \ \ (check (queue-pop! q2) =\<gtr\> 1)

    \ \ (check (queue-pop! q2) =\<gtr\> 2)

    \ \ (check (queue-pop! q2) =\<gtr\> 3)

    )

    \;
  </scm-chunk>

  <section|实现>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define-record-type :queue

    \ \ (make-queue data)

    \ \ queue?

    \ \ (data get-data set-data!))

    \;

    (define (%queue-assert-type q)

    \ \ (when (not (queue? q))

    \ \ \ \ (type-error "Parameter q is not a queue")))

    \;

    (define (%queue-assert-value q)

    \ \ (when (queue-empty? q)

    \ \ \ \ (value-error "q must be non-empty")))

    \;
  </scm-chunk>

  <paragraph|queue><index|queue>

  第一个参数是队列的头部，最后一个参数是队列的尾部。

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue . l)

    \ \ (if (null? l)

    \ \ \ \ \ \ (make-queue '())

    \ \ \ \ \ \ (make-queue l)))

    \;
  </scm-chunk>

  <paragraph|queue-empty?><index|queue-empty?><scm|(queue) =\<gtr\> bool>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-empty? q)

    \ \ (%queue-assert-type q)

    \ \ (null? (get-data q)))

    \;
  </scm-chunk>

  <paragraph|queue-size><index|queue-size><scm|(queue) =\<gtr\> int>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-size q)

    \ \ (%queue-assert-type q)

    \ \ (length (get-data q)))

    \;
  </scm-chunk>

  <paragraph|queue-front><index|queue-front><scm|(queue) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-front q)

    \ \ (%queue-assert-type q)

    \ \ (%queue-assert-value q)

    \ \ (first (get-data q)))

    \;
  </scm-chunk>

  <paragraph|queue-back><index|queue-back><scm|(queue) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-back q)

    \ \ (%queue-assert-type q)

    \ \ (%queue-assert-value q)

    \ \ (last (get-data q)))

    \;
  </scm-chunk>

  <paragraph|queue-push!><index|queue-push!><scm|(queue x) =\<gtr\> queue>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-push! q x)

    \ \ (%queue-assert-type q)

    \ \ (let1 data (get-data q)

    \ \ \ \ (set-data! q (append data (list x)))))

    \;
  </scm-chunk>

  <paragraph|queue-pop!><index|queue-pop!><scm|(queue) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-pop! q)

    \ \ (%queue-assert-type q)

    \ \ (%queue-assert-value q)

    \ \ (let1 data (get-data q)

    \ \ \ \ (set-data! q (cdr data))

    \ \ \ \ (car data)))

    \;
  </scm-chunk>

  <paragraph|queue-\<gtr\>list><index|queue-\<gtr\>list><scm|(queue) =\<gtr\> list>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-\<gtr\>list q)

    \ \ (get-data q))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/queue.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/queue-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii hash-table)>

  <section|许可证>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/hash-table.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii hash-table)

    \ \ \ \ \ \ \ \ (liii base))

    \;

    (check-set-mode! 'report-failed)

    \;

    (define empty-ht (make-hash-table))

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define-library (srfi srfi-125)

    (import (srfi srfi-1))

    (export

    \ \ make-hash-table, hash-table, hash-table-unfold, alist-\<gtr\>hash-table

    \ \ hash-table? hash-table-contains? hash-table-empty? hash-table=?

    \ \ hash-table-mutable?

    \ \ hash-table-ref hash-table-ref/default

    \ \ hash-table-set! hash-table-delete! hash-table-intern! hash-table-update!

    \ \ hash-table-update!/default hash-table-pop! hash-table-clear!

    \ \ hash-table-size hash-table-keys hash-table-values hash-table-entries

    \ \ hash-table-find hash-table-count

    )

    (begin

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/hash-table.scm|true|true>
    (define-library (liii hash-table)

    (import (srfi srfi-125))

    (export

    \ \ make-hash-table, hash-table, hash-table-unfold, alist-\<gtr\>hash-table

    \ \ hash-table? hash-table-contains? hash-table-empty? hash-table=?

    \ \ hash-table-mutable?

    \ \ hash-table-ref hash-table-ref/default

    \ \ hash-table-set! hash-table-delete! hash-table-intern! hash-table-update!

    \ \ hash-table-update!/default hash-table-pop! hash-table-clear!

    \ \ hash-table-size hash-table-keys hash-table-values hash-table-entries

    \ \ hash-table-find hash-table-count

    )

    (begin
  </scm-chunk>

  <subsection|访问哈希表中的元素>

  除了SRFI 125定义的<scm|hash-table-ref>和<scm|hash-table-ref/default>之外，我们可以用S7 Scheme内置的访问方式：

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (check (ht 'a) =\<gtr\> #f)

    \ \ (hash-table-set! ht 'a 1)

    \ \ (check (ht 'a) =\<gtr\> 1))

    \;
  </scm-chunk>

  <section|实现>

  <subsection|子函数>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (assert-hash-table-type ht f)

    \ \ (when (not (hash-table? ht))

    \ \ \ \ (error 'type-error f "this parameter must be typed as hash-table")))

    \;

    (define hash-table-set-s7 hash-table-set!)

    \;
  </scm-chunk>

  <subsection|构造器>

  <paragraph|make-hash-table>

  <paragraph|hash-table>

  <subsection|谓词>

  <paragraph|hash-table?><index|hash-table?>

  S7内置函数。判断一个对象是不是哈希表。

  <paragraph|hash-table-contains?><index|hash-table-contains?><scm|(hash-table key) =\<gtr\> bool>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-contains? ht key)

    \ \ (not (not (hash-table-ref ht key))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (hash-table-set! ht 'brand 'liii)

    \ \ (check (hash-table-contains? ht 'brand) =\<gtr\> #t)

    \ \ (hash-table-set! ht 'brand #f)

    \ \ (check (hash-table-contains? ht 'brand) =\<gtr\> #f))

    \;
  </scm-chunk>

  <paragraph|hash-table-empty?><index|hash-table-empty?>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-empty? ht)

    \ \ (zero? (hash-table-size ht)))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (check (hash-table-empty? empty-ht) =\<gtr\> #t)

    \;

    (let1 test-ht (make-hash-table)

    \ \ (hash-table-set! test-ht 'key 'value)

    \ \ (check (hash-table-empty? test-ht) =\<gtr\> #f))

    \;
  </scm-chunk>

  <paragraph|hash-table=?><index|hash-table=?><scm|(ht1 ht2) =\<gtr\> boolean>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table=? ht1 ht2)

    \ \ (equal? ht1 ht2))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let ((empty-h1 (make-hash-table))

    \ \ \ \ \ \ (empty-h2 (make-hash-table)))

    \ \ (check (hash-table=? empty-h1 empty-h2) =\<gtr\> #t))

    \;

    (let ((t1 (make-hash-table))

    \ \ \ \ \ \ (t2 (make-hash-table)))

    \ \ (hash-table-set! t1 'a 1)

    \ \ (hash-table-set! t2 'a 1)

    \ \ (check (hash-table=? t1 t2) =\<gtr\> #t)

    \ \ (hash-table-set! t1 'b 2)

    \ \ (check (hash-table=? t1 t2) =\<gtr\> #f))

    \;
  </scm-chunk>

  <subsection|选择器>

  <paragraph|hash-table-ref><index|hash-table-ref><scm|(hash-table-ref ht key) =\<gtr\> value>

  <\description>
    <item*|ht>哈希表

    <item*|key>键

    <item*|value>返回hash表中key这个键对应的值
  </description>

  SRFI 125定义的<scm|hash-table-ref>的函数签名是这样的：<scm|(hash-table-ref hash-table key [failure [success]])>。两参数形式的<scm|hash-table-ref>是S7 Scheme的内置函数。

  在S7 Scheme中，可以直接将hash-table视作一个单参数的函数，比如<scm|(ht 'key)>等价于<scm|(hash-table-ref ht 'key)>。

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (check (hash-table-ref empty-ht 'key) =\<gtr\> #f)

    \;

    (let1 ht (make-hash-table)

    \ \ (hash-table-set! ht 'key 'value)

    \ \ (check (hash-table-ref ht 'key) =\<gtr\> 'value)

    \ \ (check (ht 'key) =\<gtr\> 'value))

    \;
  </scm-chunk>

  <paragraph|hash-table-ref/default><index|hash-table-ref/default><scm|(hash-table-ref/default ht key default) =\<gtr\> value>

  <\description>
    <item*|ht>哈希表

    <item*|key>键

    <item*|default>默认值，如果key这个键在哈希表中对应的值不存在，则返回默认值。注意，该默认值只有在key这个键不存在的时候，才会被求值。

    <item*|value>键对应的值，如果不存在，则为默认值。
  </description>

  <subparagraph|测试>

  当键对应的值存在时，default不会被求值，故而测试中的<scm|(display "hello")>实际不会被执行。

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (check (hash-table-ref/default ht 'key 'value1) =\<gtr\> 'value1)

    \ \ (check (hash-table-ref/default ht 'key (+ 1 2)) =\<gtr\> 3)

    \;

    \ \ (hash-table-set! ht 'key 'value)

    \ \ (check (hash-table-ref/default ht 'key

    \ \ \ \ \ \ \ \ \ \ \ (begin (display "hello")

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (+ 1 2)))

    \ \ \ \ =\<gtr\> 'value)

    ) ; end of let1

    \;
  </scm-chunk>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define-macro (hash-table-ref/default ht key default)

    \ \ ‘(or (hash-table-ref ,ht ,key)

    \ \ \ \ \ \ \ \ ,default))

    \;
  </scm-chunk>

  <subsection|修改器>

  <paragraph|hash-table-set!><index|hash-table-set!>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (hash-table-set! ht 'k1 'v1 'k2 'v2)

    \ \ (check (ht 'k1) =\<gtr\> 'v1)

    \ \ (check (ht 'k2) =\<gtr\> 'v2)

    )

    \;
  </scm-chunk>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-set! ht . rest)

    \ \ (assert-hash-table-type ht hash-table-set!)

    \ \ (let1 len (length rest)

    \ \ \ \ (when (or (odd? len) (zero? len))

    \ \ \ \ \ \ (error 'wrong-number-of-args len "but must be even and non-zero"))

    \ \ \ \ 

    \ \ \ \ (hash-table-set-s7 ht (car rest) (cadr rest))

    \ \ \ \ (when (\<gtr\> len 2)

    \ \ \ \ \ \ \ \ \ \ (apply hash-table-set! (cons ht (cddr rest))))))

    \;
  </scm-chunk>

  <paragraph|hash-table-delete!><index|hash-table-delete!>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (hash-table-update! ht 'key 'value)

    \ \ (check (hash-table-delete! ht 'key) =\<gtr\> 1)

    \ \ (check-false (hash-table-contains? ht 'key))

    \ \ 

    \ \ (hash-table-update! ht 'key1 'value1)

    \ \ (hash-table-update! ht 'key2 'value2)

    \ \ (hash-table-update! ht 'key3 'value3)

    \ \ (hash-table-update! ht 'key4 'value4)

    \ \ (check (hash-table-delete! ht 'key1 'key2 'key3) =\<gtr\> 3)

    )

    \;
  </scm-chunk>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-delete! ht key . keys)

    \ \ (assert-hash-table-type ht hash-table-delete!)

    \ \ (let1 all-keys (cons key keys)

    \ \ \ \ (length

    \ \ \ \ \ \ (filter

    \ \ \ \ \ \ \ \ (lambda (x)

    \ \ \ \ \ \ \ \ \ \ (if (hash-table-contains? ht x)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (hash-table-set-s7 ht x #f)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ #t)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ #f))

    \ \ \ \ \ \ \ \ all-keys))))

    \;
  </scm-chunk>

  <paragraph|hash-table-update!><index|hash-table-update!>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-update! ht key value)

    \ \ (hash-table-set! ht key value))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (hash-table-update! ht 'key 'value)

    \ \ (check (ht 'key) =\<gtr\> 'value)

    \ \ (hash-table-update! ht 'key 'value1)

    \ \ (check (ht 'key) =\<gtr\> 'value1)

    \ \ (hash-table-update! ht 'key #f)

    \ \ (check (ht 'key) =\<gtr\> #f))

    \;
  </scm-chunk>

  <paragraph|hash-table-clear!><index|hash-table-clear!>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-clear! ht)

    \ \ (for-each

    \ \ \ \ (lambda (key)

    \ \ \ \ \ \ (hash-table-set! ht key #f))

    \ \ \ \ (hash-table-keys ht)))

    \;
  </scm-chunk>

  \;

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (hash-table-update! ht 'key 'value)

    \ \ (hash-table-update! ht 'key1 'value1)

    \ \ (hash-table-update! ht 'key2 'value2)

    \ \ (hash-table-clear! ht)

    \ \ (check-true (hash-table-empty? ht)))

    \;
  </scm-chunk>

  <subsection|哈希表整体>

  <paragraph|hash-table-size><index|hash-table-size>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define hash-table-size hash-table-entries)

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (check (hash-table-size empty-ht) =\<gtr\> 0)

    \;

    (let1 populated-ht (make-hash-table)

    \ \ (hash-table-set! populated-ht 'key1 'value1)

    \ \ (hash-table-set! populated-ht 'key2 'value2)

    \ \ (hash-table-set! populated-ht 'key3 'value3)

    \ \ (check (hash-table-size populated-ht) =\<gtr\> 3))

    \;
  </scm-chunk>

  <paragraph|hash-table-keys><index|hash-table-keys>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-keys ht)

    \ \ (map car (map values ht)))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (check (hash-table-keys empty-ht) =\<gtr\> '())

    \;

    (let1 ht (make-hash-table)

    \ \ (hash-table-set! ht 'k1 'v1)

    \ \ (check (hash-table-keys ht) =\<gtr\> '(k1)))

    \;
  </scm-chunk>

  <paragraph|hash-table-values><index|hash-table-values>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-values ht)

    \ \ (map cdr (map values ht)))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (check (hash-table-values empty-ht) =\<gtr\> '())

    \;

    (let1 ht (make-hash-table)

    \ \ (hash-table-set! ht 'k1 'v1)

    \ \ (check (hash-table-values ht) =\<gtr\> '(v1)))

    \;
  </scm-chunk>

  <subsection|复制和转换>

  <paragraph|hash-table-\<gtr\>alist><index|hash-table-\<gtr\>alist>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-\<gtr\>alist table)

    \ \ (map values table))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/hash-table.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <\the-index|idx>
    <index+1|???|<pageref|auto-21>>

    <index+1|any|<pageref|auto-100>>

    <index+1|circular-list|<pageref|auto-30>>

    <index+1|circular-list?|<pageref|auto-35>>

    <index+1|count|<pageref|auto-73>>

    <index+1|delete|<pageref|auto-105>>

    <index+1|delete-duplicates|<pageref|auto-107>>

    <index+1|drop|<pageref|auto-62>>

    <index+1|drop-right|<pageref|auto-66>>

    <index+1|drop-while|<pageref|auto-96>>

    <index+1|eighth|<pageref|auto-54>>

    <index+1|every|<pageref|auto-102>>

    <index+1|fifth|<pageref|auto-48>>

    <index+1|file-exists-error|<pageref|auto-13>>

    <index+1|file-not-found-error|<pageref|auto-9>>

    <index+1|filter|<pageref|auto-85>>

    <index+1|find|<pageref|auto-92>>

    <index+1|first|<pageref|auto-40>>

    <index+1|flatmap|<pageref|auto-116>>

    <index+1|fold|<pageref|auto-76>>

    <index+1|fold-right|<pageref|auto-78>>

    <index+1|fourth|<pageref|auto-46>>

    <index+1|hash-table?|<pageref|auto-178>>

    <index+1|hash-table=?|<pageref|auto-188>>

    <index+1|hash-table-clear!|<pageref|auto-212>>

    <index+1|hash-table-contains?|<pageref|auto-180>>

    <index+1|hash-table-delete!|<pageref|auto-204>>

    <index+1|hash-table-empty?|<pageref|auto-184>>

    <index+1|hash-table-\<gtr\>alist|<pageref|auto-230>>

    <index+1|hash-table-keys|<pageref|auto-221>>

    <index+1|hash-table-ref|<pageref|auto-193>>

    <index+1|hash-table-ref/default|<pageref|auto-195>>

    <index+1|hash-table-set!|<pageref|auto-200>>

    <index+1|hash-table-size|<pageref|auto-217>>

    <index+1|hash-table-update!|<pageref|auto-208>>

    <index+1|hash-table-values|<pageref|auto-225>>

    <index+1|iota|<pageref|auto-32>>

    <index+1|last|<pageref|auto-70>>

    <index+1|last-pair|<pageref|auto-68>>

    <index+1|length=?|<pageref|auto-110>>

    <index+1|list-index|<pageref|auto-98>>

    <index+1|list-not-null?|<pageref|auto-122>>

    <index+1|list-view|<pageref|auto-112>>

    <index+1|ninth|<pageref|auto-56>>

    <index+1|not-a-directory-error|<pageref|auto-11>>

    <index+1|not-null-list?|<pageref|auto-118>>

    <index+1|null-list?|<pageref|auto-37>>

    <index+1|os-error|<pageref|auto-7>>

    <index+1|partition|<pageref|auto-87>>

    <index+1|queue|<pageref|auto-150>>

    <index+1|queue-back|<pageref|auto-158>>

    <index+1|queue-empty?|<pageref|auto-152>>

    <index+1|queue-front|<pageref|auto-156>>

    <index+1|queue-\<gtr\>list|<pageref|auto-164>>

    <index+1|queue-pop!|<pageref|auto-162>>

    <index+1|queue-push!|<pageref|auto-160>>

    <index+1|queue-size|<pageref|auto-154>>

    <index+1|reduce|<pageref|auto-80>>

    <index+1|reduce-right|<pageref|auto-82>>

    <index+1|remove|<pageref|auto-89>>

    <index+1|second|<pageref|auto-42>>

    <index+1|seventh|<pageref|auto-52>>

    <index+1|sixth|<pageref|auto-50>>

    <index+1|stack|<pageref|auto-130>>

    <index+1|stack-empty?|<pageref|auto-132>>

    <index+1|stack-\<gtr\>list|<pageref|auto-142>>

    <index+1|stack-pop!|<pageref|auto-140>>

    <index+1|stack-push!|<pageref|auto-138>>

    <index+1|stack-size|<pageref|auto-134>>

    <index+1|stack-top|<pageref|auto-136>>

    <index+1|take|<pageref|auto-60>>

    <index+1|take-right|<pageref|auto-64>>

    <index+1|take-while|<pageref|auto-94>>

    <index+1|tenth|<pageref|auto-58>>

    <index+1|third|<pageref|auto-44>>

    <index+1|timeout-error|<pageref|auto-15>>

    <index+1|type-error|<pageref|auto-17>>

    <index+1|value-error|<pageref|auto-19>>
  </the-index>
</body>

<\initial>
  <\collection>
    <associate|font-base-size|8>
    <associate|page-height|auto>
    <associate|page-medium|papyrus>
    <associate|page-screen-margin|false>
    <associate|page-type|a5>
    <associate|page-width|auto>
    <associate|save-aux|false>
  </collection>
</initial>
