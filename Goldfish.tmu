<TMU|<tuple|1.0.3|1.2.9.1>>

<style|<tuple|book|chinese|literate|goldfish|reduced-margins|guile|smart-ref|preview-ref>>

<\body>
  <\hide-preamble>
    <assign|scm|<macro|body|<goldfish-lang|<arg|body>>>>

    <assign|scm-chunk|<\macro|name|prev|next|body>
      <\generic-chunk|<arg|name>|<arg|prev>|<arg|next>>
        <with|mode|prog|prog-language|goldfish|font-family|rm|<arg|body>>
      </generic-chunk>
    </macro>>

    <assign|subparagraph|<macro|title|<assign|subparagraph-numbered|<compound|subparagraph-display-numbers>><assign|subparagraph-prefix|<macro|<compound|the-subparagraph>.>><compound|next-subparagraph><compound|subparagraph-clean><compound|subparagraph-header|<arg|title>><compound|subparagraph-toc|<arg|title>><small|<if|<value|subparagraph-numbered>|<compound|subparagraph-numbered-title|<arg|title>>|<compound|subparagraph-unnumbered-title|<arg|title>>>>>>
  </hide-preamble>

  文档许可证暂时没有确定！

  \;

  <chapter|(liii base)>

  <section|许可证>

  <\scm-chunk|goldfish/scheme/base.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/base.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  \;

  <\scm-chunk|tests/goldfish/liii/base-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define-library (scheme base)

    (export

    \ \ let-values

    \ \ define-record-type

    \ \ square

    \ \ boolean=?

    \ \ ; String

    \ \ string-copy

    \ \ ; Vector

    \ \ vector-\<gtr\>string string-\<gtr\>vector

    \ \ vector-copy vector-copy! vector-fill!

    \ \ ; Input and Output

    \ \ call-with-port port? binary-port? textual-port?

    \ \ input-port-open? output-port-open?

    \ \ open-binary-input-file open-binary-output-file

    \ \ close-port

    \ \ eof-object

    \ \ ; Control flow

    \ \ string-map vector-map string-for-each vector-for-each

    \ \ ; Exception

    \ \ raise guard read-error? file-error?)

    (begin

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/base.scm|true|true>
    (define-library (liii base)

    (import (scheme base))

    (export

    \ \ ; (scheme base) defined by R7RS

    \ \ let-values

    \ \ define-record-type

    \ \ square

    \ \ boolean=?

    \ \ ; String

    \ \ string-copy

    \ \ ; Vector

    \ \ vector-\<gtr\>string string-\<gtr\>vector

    \ \ vector-copy vector-copy! vector-fill!

    \ \ ; Input and Output

    \ \ call-with-port port? binary-port? textual-port?

    \ \ input-port-open? output-port-open?

    \ \ open-binary-input-file open-binary-output-file

    \ \ close-port

    \ \ eof-object

    \ \ ; Control flow

    \ \ string-map vector-map string-for-each vector-for-each

    \ \ ; Exception

    \ \ raise guard read-error? file-error?

    \;

    \ \ ; Extra routines for (liii base)

    \ \ == != display* in? let1 compose identity typed-lambda

    )

    (begin

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii base)

    \ \ \ \ \ \ \ \ (liii list))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|表达式>

  本节对应R7RS的第四节：表达式。

  <subsection|原语表达式>

  <subsection|派生表达式>

  <paragraph|case><index|case>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (case '+

    \ \ \ \ \ \ \ \ \ ((+ -) 'p0)

    \ \ \ \ \ \ \ \ \ ((* /) 'p1))

    \ \ =\<gtr\> 'p0)

    \;

    (check (case '-

    \ \ \ \ \ \ \ \ \ ((+ -) 'p0)

    \ \ \ \ \ \ \ \ \ ((* /) 'p1))

    \ \ =\<gtr\> 'p0)

    \;

    (check (case '*

    \ \ \ \ \ \ \ \ \ ((+ -) 'p0)

    \ \ \ \ \ \ \ \ \ ((* /) 'p1))

    \ \ =\<gtr\> 'p1)

    \;

    (check (case '@

    \ \ \ \ \ \ \ \ \ ((+ -) 'p0)

    \ \ \ \ \ \ \ \ \ ((* /) 'p1))

    \ \ =\<gtr\> #\<less\>unspecified\<gtr\>)

    \;

    (check (case '&

    \ \ \ \ \ \ \ \ \ ((+ -) 'p0)

    \ \ \ \ \ \ \ \ \ ((* /) 'p1))

    \ \ =\<gtr\> #\<less\>unspecified\<gtr\>)

    \;
  </scm-chunk>

  \;

  <paragraph|let-values><index|let-values>

  \;

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    ; 0-clause BSD

    ; Bill Schottstaedt

    ; from S7 source repo: r7rs.scm

    (define-macro (let-values vars . body)

    \ \ (if (and (pair? vars)

    \ \ \ \ \ \ \ \ \ \ \ (pair? (car vars))

    \ \ \ \ \ \ \ \ \ \ \ (null? (cdar vars)))

    \ \ \ \ \ \ ‘((lambda ,(caar vars)

    \ \ \ \ \ \ \ \ \ \ ,@body)

    \ \ \ \ \ \ \ \ ,(cadar vars))

    \ \ \ \ \ \ ‘(with-let

    \ \ \ \ \ \ \ \ (apply sublet (curlet)

    \ \ \ \ \ \ \ \ \ \ (list

    \ \ \ \ \ \ \ \ \ \ \ \ ,@(map

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (lambda (v)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ‘((lambda ,(car v)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values ,@(map (lambda (name)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values (symbol-\<gtr\>keyword name) name))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let args-\<gtr\>proper-list ((args (car v)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cond ((symbol? args)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (list args))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((not (pair? args))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ args)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((pair? (car args))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons (caar args)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (args-\<gtr\>proper-list (cdr args))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons (car args)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (args-\<gtr\>proper-list (cdr args)))))))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ,(cadr v)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ vars)))

    \ \ \ \ \ \ \ \ ,@body)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (let-values (((ret) (+ 1 2))) (+ ret 4)) =\<gtr\> 7)

    \;

    (check (let-values (((a b) (values 3 4))) (+ a b)) =\<gtr\> 7)

    \;
  </scm-chunk>

  \;

  <section|程序结构>

  本节对应R7RS的第5节：程序结构。

  <paragraph|define-record-type><index|define-record-type>

  <subparagraph|实现>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    ; 0-clause BSD by Bill Schottstaedt from S7 source repo: r7rs.scm

    (define-macro (define-record-type type make ? . fields)

    \ \ (let ((obj (gensym))

    \ \ \ \ \ \ \ \ (typ (gensym)) ; this means each call on this macro makes a new type

    \ \ \ \ \ \ \ \ (args (map (lambda (field)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values (list 'quote (car field))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let ((par (memq (car field) (cdr make))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (and (pair? par) (car par)))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ fields)))

    \ \ \ \ ‘(begin

    \ \ \ \ \ \ \ (define (,? ,obj)

    \ \ \ \ \ \ \ \ \ (and (let? ,obj)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (eq? (let-ref ,obj ',typ) ',type)))

    \ \ \ \ \ \ \ 

    \ \ \ \ \ \ \ (define ,make\ 

    \ \ \ \ \ \ \ \ \ (inlet ',typ ',type ,@args))

    \;

    \ \ \ \ \ \ \ ,@(map

    \ \ \ \ \ \ \ \ \ \ (lambda (field)

    \ \ \ \ \ \ \ \ \ \ \ \ (when (pair? field)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (null? (cdr field))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (null? (cddr field))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ‘(define (,(cadr field) ,obj)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let-ref ,obj ',(car field)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ‘(begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (define (,(cadr field) ,obj)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let-ref ,obj ',(car field)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (define (,(caddr field) ,obj val)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let-set! ,obj ',(car field) val)))))))

    \ \ \ \ \ \ \ \ \ \ fields)

    \ \ \ \ \ \ \ ',type)))

    \;
  </scm-chunk>

  \;

  <subparagraph|测试>

  通过<scm|define-record-type>，定义了一种名为<scm|pare>的记录类型，其中<scm|kons>是这种记录类型的构造器，<scm|pare?>是谓词，<scm|kar>和<scm|kdr>是选择器，<scm|set-kar!>是修改器。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (define-record-type :pare

    \ \ (kons x y)

    \ \ pare?

    \ \ (x kar set-kar!)

    \ \ (y kdr))

    \;

    (check (pare? (kons 1 2)) =\<gtr\> #t)

    (check (pare? (cons 1 2)) =\<gtr\> #f)

    (check (kar (kons 1 2)) =\<gtr\> 1)

    (check (kdr (kons 1 2)) =\<gtr\> 2)

    \;

    (check

    \ (let ((k (kons 1 2)))

    \ \ \ (set-kar! k 3)

    \ \ \ (kar k))

    \ \ =\<gtr\> 3)

    \;
  </scm-chunk>

  \;

  上面那个例子比较难懂，提供一个更易懂的例子：

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (define-record-type :person

    \ \ (make-person name age)

    \ \ person?

    \ \ (name get-name set-name!)

    \ \ (age get-age))

    \;

    (check (person? (make-person "Da" 3)) =\<gtr\> #t)

    (check (get-age (make-person "Da" 3)) =\<gtr\> 3)

    (check (get-name (make-person "Da" 3)) =\<gtr\> "Da")

    (check

    \ \ (let ((da (make-person "Da" 3)))

    \ \ \ \ (set-name! da "Darcy")

    \ \ \ \ (get-name da))

    \ \ =\<gtr\> "Darcy")

    \;
  </scm-chunk>

  <subparagraph|SRFI>

  <\scm-chunk|goldfish/srfi/srfi-9.scm|false|false>
    (define-library (srfi srfi-9)

    (import (scheme base))

    (export define-record-type)

    (begin

    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  \;

  <section|相等性判断>

  <section|数值>

  <paragraph|square><index|square>

  求一个数的平方。

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (square x) (* x x))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (square 2) =\<gtr\> 4)

    \;
  </scm-chunk>

  <section|布尔值>

  <label|r7rs><paragraph|boolean=?><scm|(obj1 obj2 ...) =\<gtr\> boolean><index|boolean=?>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (boolean=? obj1 obj2 . rest)

    \ \ (define (same-boolean obj rest)

    \ \ \ \ (if (null? rest)

    \ \ \ \ \ \ \ \ #t

    \ \ \ \ \ \ \ \ (and (equal? obj (car rest))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (same-boolean obj (cdr rest)))))

    \ \ (cond ((not (boolean? obj1)) #f)

    \ \ \ \ \ \ \ \ ((not (boolean? obj2)) #f)

    \ \ \ \ \ \ \ \ ((not (equal? obj1 obj2)) #f)

    \ \ \ \ \ \ \ \ (else (same-boolean obj1 rest))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check-true (boolean=? #t #t))

    (check-true (boolean=? #f #f))

    (check-true (boolean=? #t #t #t))

    (check-false (boolean=? #t #f))

    (check-false (boolean=? #f #t))

    \;
  </scm-chunk>

  <section|序对和列表>

  见<chapter-ref|chapter:liii_list>

  <section|字符>

  <paragraph|char?><index|char?>

  判断一个对象x是否是字符类型。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (char? #\\A) =\<gtr\> #t)

    (check (char? 1) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|char=?><index|char=?>

  判断两个及以上字符对象是否相等。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (char=? #\\A #\\A) =\<gtr\> #t)

    (check (char=? #\\A #\\A #\\A) =\<gtr\> #t)

    (check (char=? #\\A #\\a) =\<gtr\> #f)

    \;
  </scm-chunk>

  <section|字符串>

  见<smart-ref|chapter:liii_string>

  <section|向量>

  见<smart-ref|chapter:liii_vector>

  <section|字节向量>

  <section|控制流>

  <paragraph|procedure?><index|procedure?>

  <paragraph|apply><index|apply>

  <scm|apply>是R7RS定义的函数。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (apply + (list 3 4)) =\<gtr\> 7)

    (check (apply + (list 2 3 4)) =\<gtr\> 9)

    \;
  </scm-chunk>

  在这个例子中，<scm|(apply + (list 3 4))>实际被展开为<scm|(+ 3 4)>。<scm|+>这个函数接受两个参数，但是无法接受一个列表，利用<scm|apply>就可以把列表展开并作为<scm|+>的两个参数。

  <\big-figure|<scm|<tree|apply|+|(list 3 4)>><space|1em><math|\<Rightarrow\>><space|1em><scm|<tree|+|3|4>>>
    apply的原理可视化
  </big-figure>

  <paragraph|call-with-current-continuation>

  <paragraph|call/cc>

  <paragraph|values>

  <paragraph|call-with-values>

  <paragraph|dynamic-wind>

  <section|异常处理>

  <paragraph|guard><index|guard>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (raise . args)

    \ \ (apply throw #t args))

    \;

    (define-macro (guard results . body)

    \ \ ‘(let ((,(car results)\ 

    \ \ \ \ \ \ \ \ \ \ (catch #t\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ ,@body)\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (lambda (type info)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (pair? (*s7* 'catches))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (lambda () (apply throw type info))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car info))))))

    \ \ \ \ \ (cond ,@(cdr results)

    \ \ \ \ \ \ \ \ \ \ \ (else\ 

    \ \ \ \ \ \ \ \ \ \ \ \ (if (procedure? ,(car results))\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (,(car results))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ,(car results))))))

    \;
  </scm-chunk>

  测试用例

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (guard (condition

    \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ (display "condition: ")

    \ \ \ \ \ \ \ \ \ \ (write condition)

    \ \ \ \ \ \ \ \ \ \ (newline)

    \ \ \ \ \ \ \ \ \ \ 'exception))

    \ \ (+ 1 (raise 'an-error)))

    ; PRINTS: condition: an-error

    \;

    (guard (condition

    \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ (display "something went wrong")

    \ \ \ \ \ \ \ \ \ \ (newline)

    \ \ \ \ \ \ \ \ \ \ 'dont-care))

    \ (+ 1 (raise 'an-error)))

    ; PRINTS: something went wrong

    \;
  </scm-chunk>

  <paragraph|read-error?><index|read-error?>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (read-error? obj) (eq? (car obj) 'read-error))

    \;
  </scm-chunk>

  <paragraph|file-error?><index|file-error?>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (file-error? obj) (eq? (car obj) 'io-error))

    \;
  </scm-chunk>

  <section|输入和输出>

  <subsection|端口>

  <paragraph|call-with-port><index|call-with-port>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (call-with-port port proc)

    \ \ (let ((res (proc port)))

    \ \ \ \ (if res (close-port port))

    \ \ \ \ res))

    \;
  </scm-chunk>

  <paragraph|input-port?><index|input-port?>

  S7内置函数。

  <paragraph|output-port?><index|output-port?>

  S7内置函数。

  <paragraph|port?><index|port?>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (port? p) (or (input-port? p) (output-port? p)))

    \;
  </scm-chunk>

  <paragraph|textual-port?><index|textual-port?>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define textual-port? port?)

    \;
  </scm-chunk>

  <paragraph|binary-port?><index|binary-port?>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define binary-port? port?)

    \;
  </scm-chunk>

  <paragraph|input-port-open?><index|input-port-open?>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (input-port-open? p) (not (port-closed? p)))

    \;
  </scm-chunk>

  <paragraph|output-port-open?><index|output-port-open?>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (output-port-open? p) (not (port-closed? p)))

    \;
  </scm-chunk>

  <paragraph|close-port><index|close-port>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (close-port p)

    \ \ (if (input-port? p)

    \ \ \ \ \ \ (close-input-port p)

    \ \ \ \ \ \ (close-output-port p)))

    \;
  </scm-chunk>

  <paragraph|close-input-port><index|close-input-port>

  S7内置函数。

  <paragraph|close-output-port><index|close-output-port>

  S7内置函数。

  <subsection|输入>

  <paragraph|read>

  <paragraph|read-char>

  <paragraph|peek-char>

  <paragraph|read-line>

  <paragraph|eof-object?>

  <paragraph|eof-object><index|eof-object>

  <subparagraph|实现>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (eof-object) #\<less\>eof\<gtr\>)

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (eof-object) =\<gtr\> #\<less\>eof\<gtr\>)

    \;
  </scm-chunk>

  <paragraph|char-ready?>

  <paragraph|read-string>

  <paragraph|read-u8>

  <paragraph|peek-u8>

  <paragraph|u8-ready?>

  <paragraph|read-bytevector>

  <paragraph|read-bytevector!>

  <subsection|输出>

  <section|系统接口>

  <section|三鲤扩展库>

  <paragraph|==><index|==><scm|(x y) =\<gtr\> bool>

  <scm|equal?>的语法糖。

  <\scm-chunk|goldfish/liii/base.scm|true|true>
    (define == equal?)

    \;
  </scm-chunk>

  \;

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (== (list 1 2) (list 1 2)) =\<gtr\> #t)

    (check (!= (list 1 2) (list 1 2)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|!=><index|!=><scm|(x y) =\<gtr\> bool>

  语法糖。

  <\scm-chunk|goldfish/liii/base.scm|true|true>
    (define (!= left right)

    \ \ (not (equal? left right)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (== (list 1 2) (list 1 2)) =\<gtr\> #t)

    (check (!= (list 1 2) (list 1 2)) =\<gtr\> #f)

    \;
  </scm-chunk>

  \;

  <paragraph|display*><index|display*><scm|(x y z ...) =\<gtr\> \<less\>#unspecified\<gtr\>>

  <scm|display*>可以输入多个参数，是<scm|display>的加强版。

  <\scm-chunk|goldfish/liii/base.scm|true|true>
    (define (display* . params)

    \ \ (for-each display params))

    \;
  </scm-chunk>

  \;

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check

    \ \ (with-output-to-string

    \ \ \ \ (lambda ()

    \ \ \ \ \ \ (display* "hello world" "\\n")))

    \ \ =\<gtr\> "hello world\\n")

    \;
  </scm-chunk>

  <paragraph|in?><index|in?><scm|(x sequence) =\<gtr\> bool>

  判断一个元素是否在对象中：

  <\enumerate>
    <item>一个元素是否在列表中

    <item>一个元素是否在向量中

    <item>一个字符是否在字符串中
  </enumerate>

  其中的相等性判断使用的是<scm|==>，也就是R7RS定义的<scm|equal?>。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (in? 1 (list )) =\<gtr\> #f)

    (check (in? 1 (list 3 2 1)) =\<gtr\> #t)

    (check (in? #\\x "texmacs") =\<gtr\> #t)

    (check (in? 1 (vector )) =\<gtr\> #f)

    (check (in? 1 (vector 3 2 1)) =\<gtr\> #t)

    (check-catch 'type-error (in? 1 "123"))

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/base.scm|true|true>
    (define (in? elem l)

    \ \ (cond ((list? l) (not (not (member elem l))))

    \ \ \ \ \ \ \ \ ((vector? l)

    \ \ \ \ \ \ \ \ \ (let loop ((i (- (vector-length l) 1)))

    \ \ \ \ \ \ \ \ \ \ \ (if (\<less\> i 0)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ #f

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (== elem (vector-ref l i))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ #t

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (- i 1))))))

    \ \ \ \ \ \ \ \ ((and (char? elem) (string? l))

    \ \ \ \ \ \ \ \ \ (in? elem (string-\<gtr\>list l)))

    \ \ \ \ \ \ \ \ (else (error 'type-error "type mismatch"))))

    \;
  </scm-chunk>

  <paragraph|let1><index|let1>

  let的语法嵌套层次太多了，故而引入let1，作为let的单参数版本，简化语法。

  <\scm-chunk|goldfish/liii/base.scm|true|true>
    (define-macro (let1 name1 value1 . body)

    \ \ ‘(let ((,name1 ,value1))

    \ \ \ \ \ ,@body))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (let1 x 1 x) =\<gtr\> 1)

    (check (let1 x 1 (+ x 1)) =\<gtr\> 2)

    \;
  </scm-chunk>

  <paragraph|identity><index|identity><scm|(x) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/base.scm|true|true>
    (define identity (lambda (x) x))

    \;
  </scm-chunk>

  <paragraph|compose><index|compose><scm|(f g ...) =\<gtr\> f>

  <\scm-chunk|goldfish/liii/base.scm|true|true>
    (define (compose . fs)

    \ \ (if (null? fs)

    \ \ \ \ \ \ (lambda (x) x)

    \ \ \ \ \ \ (lambda (x)

    \ \ \ \ \ \ \ \ ((car fs) ((apply compose (cdr fs)) x)))))

    \ \ 
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check-true ((compose not zero?) 1))

    (check-false ((compose not zero?) 0))

    \;
  </scm-chunk>

  <paragraph|typed-lambda><index|typed-lambda>

  <subparagraph|实现>

  <\scm-chunk|goldfish/liii/base.scm|true|true>
    ; 0 clause BSD, from S7 repo stuff.scm

    (define-macro (typed-lambda args . body)

    \ \ ; (typed-lambda ((var [type])...) ...)

    \ \ (if (symbol? args)

    \ \ \ \ \ \ (apply lambda args body)

    \ \ \ \ \ \ (let ((new-args (copy args)))

    \ \ \ \ \ \ \ \ (do ((p new-args (cdr p)))

    \ \ \ \ \ \ \ \ \ \ \ \ ((not (pair? p)))

    \ \ \ \ \ \ \ \ \ \ (if (pair? (car p))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (set-car! p (caar p))))

    \ \ \ \ \ \ \ \ ‘(lambda ,new-args

    \ \ \ \ \ \ \ \ \ \ \ ,@(map (lambda (arg)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (pair? arg)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ‘(unless (,(cadr arg) ,(car arg))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (error 'type-error

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "~S is not ~S~%" ',(car arg) ',(cadr arg)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (values)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ args)

    \ \ \ \ \ \ \ \ \ \ \ ,@body))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (define add3

    \ \ (typed-lambda

    \ \ \ \ ((i integer?) (x real?) z)

    \ \ \ \ (+ i x z)))

    \;

    (check (add3 1 2 3) =\<gtr\> 6)

    (check-catch 'type-error (add3 1.2 2 3))

    \;
  </scm-chunk>

  \;

  <section|结尾>

  <\scm-chunk|goldfish/liii/base.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  \;

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii error)>

  异常的命名参考Python标准库的<hlink|内置异常|https://docs.python.org/3/library/exceptions.html>。

  <section|许可证>

  <\scm-chunk|goldfish/liii/error.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    ; see https://docs.python.org/3/library/exceptions.html#exception-hierarchy

    (define-library (liii error)

    (export ???

    \ \ os-error file-not-found-error not-a-directory-error file-exists-error

    \ \ timeout-error

    \ \ type-error value-error)

    (begin

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii error))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|实现>

  <paragraph|os-error><index|os-error>

  系统级别的错误。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (os-error . args)

    \ \ (apply error (cons 'os-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'os-error (os-error))

    \;
  </scm-chunk>

  <paragraph|file-not-found-error><index|file-not-found-error>

  文件未找到。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (file-not-found-error . args)

    \ \ (apply error (cons 'file-not-found-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'file-not-found-error (file-not-found-error))

    \;
  </scm-chunk>

  <paragraph|not-a-directory-error><index|not-a-directory-error>

  不是一个目录。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (not-a-directory-error . args)

    \ \ (apply error (cons 'not-a-directory-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'not-a-directory-error (not-a-directory-error))

    \;
  </scm-chunk>

  <paragraph|file-exists-error><index|file-exists-error>

  文件已存在。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (file-exists-error . args)

    \ \ (apply error (cons 'file-exists-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'file-exists-error (file-exists-error))

    \;
  </scm-chunk>

  <paragraph|timeout-error><index|timeout-error>

  超时错误。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (timeout-error . args)

    \ \ (apply error (cons 'timeout-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'timeout-error (timeout-error))

    \;
  </scm-chunk>

  <paragraph|type-error><index|type-error>

  如果类型不匹配，直接报错。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (type-error . args)

    \ \ (apply error (cons 'type-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'type-error (type-error))

    (check-catch 'type-error (type-error "msg"))

    (check-catch 'type-error (type-error "msg" "msg2"))

    \;
  </scm-chunk>

  <paragraph|value-error><index|value-error>

  值不正确

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (value-error . args)

    \ \ (apply error (cons 'value-error args)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'value-error (value-error))

    \;
  </scm-chunk>

  <paragraph|???><index|???>

  Scala风格未实现错误，一般用于标记为实现的接口。

  <\scm-chunk|goldfish/liii/error.scm|true|true>
    (define (???)

    \ \ (error 'not-implemented-error "???"))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|true>
    (check-catch 'not-implemented-error (???))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/error.scm|true|false>
    ) ; begin

    ) ; define-library

    \;
  </scm-chunk>

  \;

  <\scm-chunk|tests/goldfish/liii/error-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii check)>

  <section|协议>

  <\scm-chunk|goldfish/liii/check.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-78.scm|false|true>
    ; \<less\>PLAINTEXT\<gtr\>

    ; Copyright (c) 2005-2006 Sebastian Egner.

    ;\ 

    ; Permission is hereby granted, free of charge, to any person obtaining

    ; a copy of this software and associated documentation files (the

    ; ''Software''), to deal in the Software without restriction, including

    ; without limitation the rights to use, copy, modify, merge, publish,

    ; distribute, sublicense, and/or sell copies of the Software, and to

    ; permit persons to whom the Software is furnished to do so, subject to

    ; the following conditions:

    ;\ 

    ; The above copyright notice and this permission notice shall be

    ; included in all copies or substantial portions of the Software.

    ;\ 

    ; THE SOFTWARE IS PROVIDED ‘‘AS IS'', WITHOUT WARRANTY OF ANY KIND,

    ; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

    ; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

    ; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE

    ; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION

    ; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION

    ; WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    ;\ 

    ; -----------------------------------------------------------------------

    ;\ 

    ; Lightweight testing (reference implementation)

    ; ==============================================

    ;

    ; Sebastian.Egner@philips.com

    ; in R5RS + SRFI 23 (error) + SRFI 42 (comprehensions)

    ;

    ; history of this file:

    ; \ \ SE, 25-Oct-2004: first version based on code used in SRFIs 42 and 67

    ; \ \ SE, 19-Jan-2006: (arg ...) made optional in check-ec

    ;

    ; Naming convention "check:\<less\>identifier\<gtr\>" is used only internally.

    ;

    ; Copyright (c) 2024 The Goldfish Scheme Authors

    ; Follow the same License as the original one

    \;
  </scm-chunk>

  \;

  <\scm-chunk|tests/goldfish/srfi/srfi-78-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  \;

  <section|接口>

  将<scm|check:proc>导出的原因是<scm|check>是使用宏实现的，而宏里面用到了<scm|check:proc>，不导出无法生效。

  <\scm-chunk|goldfish/liii/check.scm|true|true>
    (define-library (liii check)

    (export test check check-set-mode! check:proc

    \ \ check-catch check-report check-failed?

    \ \ check-true check-false)

    (import (srfi srfi-78)

    \ \ \ \ \ \ \ \ (rename (srfi srfi-78)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (check-report srfi-78-check-report)))

    (begin

    \;
  </scm-chunk>

  \;

  <\scm-chunk|goldfish/srfi/srfi-78.scm|true|true>
    (define-library (srfi srfi-78)

    (export check check-set-mode! check-report check-reset!

    \ \ \ \ \ \ \ \ check-passed? check-failed?

    \ \ \ \ \ \ \ \ check:proc)

    (begin

    \;
  </scm-chunk>

  \;

  \;

  \;

  <section|实现>

  使用display作为测试结果的展示函数，比write好，因为display可以正常显示文本中的汉字。

  <\scm-chunk|goldfish/srfi/srfi-78.scm|true|true>
    (define check:write display)

    \;
  </scm-chunk>

  <paragraph|check-set-mode!><index|check-set-mode!>

  \;

  <\scm-chunk|goldfish/srfi/srfi-78.scm|true|true>
    (define check:mode #f)

    \;

    (define (check-set-mode! mode)

    \ \ (set! check:mode

    \ \ \ \ \ \ \ \ (case mode

    \ \ \ \ \ \ \ \ \ \ ((off) \ \ \ \ \ \ \ \ \ \ 0)

    \ \ \ \ \ \ \ \ \ \ ((summary) \ \ \ \ \ \ 1)

    \ \ \ \ \ \ \ \ \ \ ((report-failed) 10)

    \ \ \ \ \ \ \ \ \ \ ((report) \ \ \ \ \ \ \ 100)

    \ \ \ \ \ \ \ \ \ \ (else (error "unrecognized mode" mode)))))

    \;

    \;
  </scm-chunk>

  将检查模式初始化为<scm|'report>：

  <\scm-chunk|goldfish/srfi/srfi-78.scm|true|true>
    (check-set-mode! 'report)

    \;
  </scm-chunk>

  以<scm|check>函数为例，不同的检查模式下，得到的结果不同。可以使用单元测试来查看这四种测试用例具体使用方法：

  <\scm-chunk|tests/goldfish/srfi/srfi-78-test.scm|true|true>
    (import (srfi srfi-78))

    \;
  </scm-chunk>

  <\description>
    <item*|report>默认检查模式，无论正确还是错误，都会展示详细的信息。

    <\scm-chunk|tests/goldfish/srfi/srfi-78-test.scm|true|true>
      ;

      ; Copyright (C) 2024 The Goldfish Scheme Authors

      ;

      ; Licensed under the Apache License, Version 2.0 (the "License");

      ; you may not use this file except in compliance with the License.

      ; You may obtain a copy of the License at

      ;

      ; http://www.apache.org/licenses/LICENSE-2.0

      ;

      ; Unless required by applicable law or agreed to in writing, software

      ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

      ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

      ; License for the specific language governing permissions and limitations

      ; under the License.

      ;

      \;

      (display "----------\\n")

      (display "check mode: report\\n")

      \;

      (check-set-mode! 'report)

      \;

      (check (+ 1 2) =\<gtr\> 3)

      \;

      (check (+ 1 2) =\<gtr\> 4)

      \;

      (check-reset!)

      \;
    </scm-chunk>

    <item*|off>设置为off的时候，禁用后续的测试用例。

    <\scm-chunk|tests/goldfish/srfi/srfi-78-test.scm|true|true>
      (display "\\n----------\\n")

      (display "check mode: off\\n")

      \;

      (check-set-mode! 'off)

      \;

      (check (+ 1 2) =\<gtr\> 3)

      \;

      (check (+ 1 2) =\<gtr\> 4)

      \;

      (check-reset!)

      \;
    </scm-chunk>

    <item*|report-failed>设置为report-failed的时候，在check正确时只返回正确的测试数量，在check错误时，显示错误。

    <\scm-chunk|tests/goldfish/srfi/srfi-78-test.scm|true|true>
      (display "\\n----------\\n")

      (display "check mode: report-failed\\n")

      \;

      (check-set-mode! 'report-failed)

      \;

      (check (+ 1 2) =\<gtr\> 3)

      \;

      (check (+ 1 2) =\<gtr\> 4)

      \;

      (check-reset!)

      \;
    </scm-chunk>

    <item*|summary>设置为summary的时候，不汇报错误，需要显示调用<scm|check-report>才能显示的测试汇总结果，显式调用<scm|check:failed>显式查看错误的例子。

    <\scm-chunk|tests/goldfish/srfi/srfi-78-test.scm|true|true>
      (display "\\n----------\\n")

      (display "check mode: summary\\n")

      \;

      (check-set-mode! 'summary)

      \;

      (check (+ 1 2) =\<gtr\> 3)

      \;

      (check (+ 1 2) =\<gtr\> 4)

      \;

      (check-report)

      \;
    </scm-chunk>

    这个时候如果需要查看错误，那么可以重新设置检查模式，重新检查报告：

    <\scm-chunk|tests/goldfish/srfi/srfi-78-test.scm|true|false>
      (check-set-mode! 'report)

      \;

      (check-report)

      \;
    </scm-chunk>
  </description>

  <paragraph|check-failed?><index|check-failed?>

  \;

  <\scm-chunk|goldfish/srfi/srfi-78.scm|true|true>
    (define check:correct 0)

    (define check:failed '())

    \;

    (define (check-reset!)

    \ \ (set! check:correct 0)

    \ \ (set! check:failed '()))

    \;

    (define (check:add-correct!)

    \ \ (set! check:correct (+ check:correct 1)))

    \;

    (define (check:add-failed! expression actual-result expected-result)

    \ \ (set! check:failed

    \ \ \ \ \ \ \ \ (cons (list expression actual-result expected-result)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ check:failed)))

    \;
  </scm-chunk>

  \;

  <\scm-chunk|goldfish/srfi/srfi-78.scm|true|true>
    (define (check:report-expression expression)

    \ \ (newline)

    \ \ (check:write expression)

    \ \ (display " =\<gtr\> "))

    \;

    (define (check:report-actual-result actual-result)

    \ \ (check:write actual-result)

    \ \ (display " ; "))

    \;

    (define (check:report-correct cases)

    \ \ (display "correct")

    \ \ (if (not (= cases 1))

    \ \ \ \ \ \ (begin (display " (")

    \ \ \ \ \ \ \ \ \ \ \ \ \ (display cases)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (display " cases checked)")))

    \ \ (newline))

    \;

    (define (check:report-failed expected-result)

    \ \ (display "*** failed ***")

    \ \ (newline)

    \ \ (display "; expected result: ")

    \ \ (check:write expected-result)

    \ \ (newline))

    \;

    (define (check-passed? expected-total-count)

    \ \ (and (= (length check:failed) 0)

    \ \ \ \ \ \ \ (= check:correct expected-total-count)))

    \;

    (define (check-failed?)

    \ \ (\<gtr\>= (length check:failed) 1))

    \;
  </scm-chunk>

  <paragraph|check><index|check>

  check的具体过程，依据不同的检查模式，做不同的处理：

  <\scm-chunk|goldfish/srfi/srfi-78.scm|true|true>
    (define (check:proc expression thunk equal expected-result)

    \ \ (case check:mode

    \ \ \ \ ((0) #f)

    \ \ \ \ ((1)

    \ \ \ \ \ (let ((actual-result (thunk)))

    \ \ \ \ \ \ \ (if (equal actual-result expected-result)

    \ \ \ \ \ \ \ \ \ \ \ (check:add-correct!)

    \ \ \ \ \ \ \ \ \ \ \ (check:add-failed! expression actual-result expected-result))))

    \ \ \ \ ((10)

    \ \ \ \ \ (let ((actual-result (thunk)))

    \ \ \ \ \ \ \ (if (equal actual-result expected-result)

    \ \ \ \ \ \ \ \ \ \ \ (check:add-correct!)

    \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ (check:report-expression expression)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (check:report-actual-result actual-result)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (check:report-failed expected-result)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (check:add-failed! expression actual-result expected-result)))))

    \ \ \ \ ((100)

    \ \ \ \ \ (check:report-expression expression)

    \ \ \ \ \ (let ((actual-result (thunk)))

    \ \ \ \ \ \ \ (check:report-actual-result actual-result)

    \ \ \ \ \ \ \ (if (equal actual-result expected-result)

    \ \ \ \ \ \ \ \ \ \ \ (begin (check:report-correct 1)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (check:add-correct!))

    \ \ \ \ \ \ \ \ \ \ \ (begin (check:report-failed expected-result)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (check:add-failed! expression\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ actual-result\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ expected-result)))))

    \ \ \ \ (else (error "unrecognized check:mode" check:mode))))

    \;
  </scm-chunk>

  check的接口实现，使用S7 Scheme的<scm|define-macro>实现：

  <\scm-chunk|goldfish/srfi/srfi-78.scm|true|true>
    (define-macro (check expr =\<gtr\> expected)

    \ \ ‘(check:proc ',expr (lambda () ,expr) equal? ,expected))

    \;
  </scm-chunk>

  <paragraph|check-true><index|check-true>

  <\scm-chunk|goldfish/liii/check.scm|true|true>
    (define-macro (check-true body)

    \ \ ‘(check ,body =\<gtr\> #t))

    \;
  </scm-chunk>

  <paragraph|check-false><index|check-false>

  <\scm-chunk|goldfish/liii/check.scm|true|true>
    (define-macro (check-false body)

    \ \ ‘(check ,body =\<gtr\> #f))

    \;
  </scm-chunk>

  <paragraph|check-catch><index|check-catch>

  <\scm-chunk|goldfish/liii/check.scm|true|true>
    (define-macro (check-catch error-id body)

    \ \ ‘(check

    \ \ \ \ (catch ,error-id

    \ \ \ \ \ \ (lambda () ,body)

    \ \ \ \ \ \ (lambda args ,error-id))

    \ \ \ \ \ \ =\<gtr\> ,error-id))

    \;
  </scm-chunk>

  <paragraph|test><index|test><scm|(obj1 obj2) =\<gtr\> boolean>

  <scm|test>函数是为了兼容S7 Scheme仓库里面的测试用例。

  <\scm-chunk|goldfish/liii/check.scm|true|true>
    (define-macro (test left right)

    \ \ ‘(check ,left =\<gtr\> ,right))

    \;
  </scm-chunk>

  <paragraph|check-report><index|check-report>

  <\scm-chunk|goldfish/liii/check.scm|true|true>
    (define (check-report . msg)

    \ \ (if (not (null? msg))

    \ \ \ \ (begin

    \ \ \ \ \ \ (display (car msg))))

    \ \ (srfi-78-check-report)

    \ \ (if (check-failed?) (exit -1)))

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-78.scm|true|true>
    (define (check-report)

    \ \ (if (\<gtr\>= check:mode 1)

    \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ (newline)

    \ \ \ \ \ \ \ \ (display "; *** checks *** : ")

    \ \ \ \ \ \ \ \ (display check:correct)

    \ \ \ \ \ \ \ \ (display " correct, ")

    \ \ \ \ \ \ \ \ (display (length check:failed))

    \ \ \ \ \ \ \ \ (display " failed.")

    \ \ \ \ \ \ \ \ (if (or (null? check:failed) (\<less\>= check:mode 1))

    \ \ \ \ \ \ \ \ \ \ \ \ (newline)

    \ \ \ \ \ \ \ \ \ \ \ \ (let* ((w (car (reverse check:failed)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (expression (car w))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (actual-result (cadr w))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (expected-result (caddr w)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (display " First failed example:")

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (newline)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (check:report-expression expression)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (check:report-actual-result actual-result)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (check:report-failed expected-result))))))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/srfi/srfi-78.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/check.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <chapter|(liii string)><label|chapter:liii_string>

  <section|许可证>

  <\scm-chunk|goldfish/liii/string.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/string.scm|true|false>
    (define-library (liii string)

    (export

    \ \ ; S7 built-in

    \ \ string? string-ref string-length

    \ \ ; from (scheme base)

    \ \ string-copy string-for-each string-map

    \ \ ; from (srfi srfi-13)

    \ \ string-null? string-join

    \ \ string-every string-any

    \ \ string-take string-take-right string-drop string-drop-right

    \ \ string-pad string-pad-right

    \ \ string-trim string-trim-right string-trim-both

    \ \ string-prefix? string-suffix?

    \ \ string-index string-index-right

    \ \ string-contains string-count

    \ \ string-reverse

    \ \ string-tokenize

    )

    (import (srfi srfi-13)

    \ \ \ \ \ \ \ \ (scheme base)

    \ \ \ \ \ \ \ \ (liii error))

    (begin

    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define-library (srfi srfi-13)

    \ \ (import

    \ \ \ \ (scheme base)

    \ \ \ \ (srfi srfi-1))

    \ \ (export

    \ \ \ \ string-null? string-copy string-join

    \ \ \ \ string-every string-any

    \ \ \ \ string-take string-take-right string-drop string-drop-right\ 

    \ \ \ \ string-pad string-pad-right

    \ \ \ \ string-trim string-trim-right string-trim-both

    \ \ \ \ string-prefix? string-suffix?\ 

    \ \ \ \ string-index string-index-right

    \ \ \ \ string-contains string-count

    \ \ \ \ string-reverse

    \ \ \ \ string-tokenize)

    (begin

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii string))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|内部公共子函数>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (%string-from-range str start_end)

    \ \ (cond ((null-list? start_end) str)

    \ \ \ \ \ \ \ \ ((= (length start_end) 1)

    \ \ \ \ \ \ \ \ \ \ (substring str (car start_end)))

    \ \ \ \ \ \ \ \ ((= (length start_end) 2)

    \ \ \ \ \ \ \ \ \ (substring str (first start_end) (second start_end)))

    \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args "%string-from-range"))))

    \;
  </scm-chunk>

  <todo|测试一下边界条件，这样后面漏测也没关系了。>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (%make-criterion char/pred?)

    \ \ (cond ((char? char/pred?) (lambda (x) (char=? x char/pred?)))

    \ \ \ \ \ \ \ \ ((procedure? char/pred?) char/pred?)

    \ \ \ \ \ \ \ \ (else (error 'wrong-type-arg "%make-criterion"))))

    \;
  </scm-chunk>

  <section|谓词>

  <label|r7rs><paragraph|string?><index|string?>

  <scm|string?>是一个S7内置的谓词函数，当且仅当参数对象类型是字符串（例如<scm|"MathAgape">）时返回<scm|#t>，否则都返回<scm|#f>。当参数为符号（例如<scm|'MathAgape>）、字符（例如<scm|#/MathAgape>）、数字（例如<scm|123>）、列表（例如<scm|'(1 2 3)>）这些非字符串类型时，都返回<scm|#f>。<scm|string?>用于确定对象是否可以被当作字符串处理，在需要执行对字符串特定操作时特别有用，避免类型错误。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (string? "MathAgape") =\<gtr\> #t)

    (check (string? "") =\<gtr\> #t)

    \;

    (check (string? 'MathAgape) =\<gtr\> #f)

    (check (string? #/MathAgape) =\<gtr\> #f)

    (check (string? 123) =\<gtr\> #f)

    (check (string? '(1 2 3)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <section|列表-字符串转换>

  <label|r7rs><paragraph|string-\<gtr\>list><index|string-\<gtr\>list>

  <scm|string-\<gtr\>list>是一个S7内置的函数，用于将字符串转换为字符列表。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check

    \ \ (string-\<gtr\>list "MathAgape")

    \ \ =\<gtr\>

    \ \ '(#\\M #\\a #\\t #\\h #\\A #\\g #\\a #\\p #\\e))

    \;

    (check (string-\<gtr\>list "") =\<gtr\> '())

    \;
  </scm-chunk>

  <label|r7rs><paragraph|list-\<gtr\>string><index|list-\<gtr\>string>

  <scm|list-\<gtr\>string>是一个S7内置的函数，用于将字符列表转换为字符串。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check

    \ \ (list-\<gtr\>string '(#\\M #\\a #\\t #\\h #\\A #\\g #\\a #\\p #\\e))

    \ \ =\<gtr\>

    \ \ "MathAgape")

    \;

    (check (list-\<gtr\>string '()) =\<gtr\> "")

    \;
  </scm-chunk>

  <paragraph|string-join><scm|(l [delim [grammer]]) =\<gtr\> string><index|string-join>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-join l . delim+grammer)

    \ \ (define (extract-params params-l)

    \ \ \ \ (cond ((null-list? params-l)

    \ \ \ \ \ \ \ \ \ \ \ (list "" 'infix))

    \ \ \ \ \ \ \ \ \ \ ((and (= (length params-l) 1)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (string? (car params-l)))

    \ \ \ \ \ \ \ \ \ \ \ (list (car params-l) 'infix))

    \ \ \ \ \ \ \ \ \ \ ((and (= (length params-l) 2)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (string? (first params-l))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (symbol? (second params-l)))

    \ \ \ \ \ \ \ \ \ \ \ params-l)

    \ \ \ \ \ \ \ \ \ \ ((\<gtr\> (length params-l) 2)

    \ \ \ \ \ \ \ \ \ \ \ (error 'wrong-number-of-args "optional params in string-join"))

    \ \ \ \ \ \ \ \ \ \ (else (error 'type-error "optional params in string-join"))))

    \ \ 

    \ \ (define (string-join-sub l delim)

    \ \ \ \ (cond ((null-list? l) "")

    \ \ \ \ \ \ \ \ \ \ ((= (length l) 1) (car l))

    \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ \ (string-append

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car l)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ delim

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (string-join-sub (cdr l) delim)))))

    \ \ 

    \ \ (let* ((params \ (extract-params delim+grammer))

    \ \ \ \ \ \ \ \ \ (delim \ \ (first params))

    \ \ \ \ \ \ \ \ \ (grammer (second params))

    \ \ \ \ \ \ \ \ \ (ret \ \ \ \ (string-join-sub l delim)))

    \ \ \ \ (case grammer

    \ \ \ \ \ \ ('infix ret)

    \ \ \ \ \ \ ('strict-infix

    \ \ \ \ \ \ \ (if (null-list? l)

    \ \ \ \ \ \ \ \ \ \ \ (error 'value-error "empty list not allowed")

    \ \ \ \ \ \ \ \ \ \ \ ret))

    \ \ \ \ \ \ ('suffix

    \ \ \ \ \ \ \ \ (if (null-list? l) "" (string-append ret delim)))

    \ \ \ \ \ \ ('prefix

    \ \ \ \ \ \ \ \ (if (null-list? l) "" (string-append delim ret)))

    \ \ \ \ \ \ (else (error 'value-error "invalid grammer")))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-join '("a" "b" "c")) =\<gtr\> "abc")

    \;

    (check (string-join '("a" "b" "c") ":") =\<gtr\> "a:b:c")

    (check (string-join '("a" "b" "c") ":" 'infix) =\<gtr\> "a:b:c")

    (check (string-join '("a" "b" "c") ":" 'suffix) =\<gtr\> "a:b:c:")

    (check (string-join '("a" "b" "c") ":" 'prefix) =\<gtr\> ":a:b:c")

    \;

    (check (string-join '() ":") =\<gtr\> "")

    (check (string-join '() ":" 'infix) =\<gtr\> "")

    (check (string-join '() ":" 'prefix) =\<gtr\> "")

    (check (string-join '() ":" 'suffix) =\<gtr\> "")

    \;

    (check-catch 'value-error (string-join '() ":" 'strict-infix))

    (check-catch 'type-error (string-join '() ":" 2))

    (check-catch 'value-error (string-join '() ":" 'no-such-grammer))

    \;

    (check

    \ \ (catch 'wrong-number-of-args

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-join '() ":" 1 2 3))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <section|谓词>

  <paragraph|string-null?><index|string-null?><scm|(str) =\<gtr\> boolean>

  <scm|<code|<code*|string-null?>>>是一个谓词函数，当且仅当参数字符串为空（即长度为0）时返回<scm|#t>，否则都返回<scm|#f>，也就是说，当参数是非字符串或长度不为0的字符串时，返回<scm|#f>。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-null? str)

    \ \ (and (string? str)\ 

    \ \ \ \ \ \ \ ((lambda (x) (= x 0)) (string-length str))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check-true (string-null? ""))

    \;

    (check-false (string-null? "MathAgape"))

    \;

    (check-false (string-null? 'not-a-string))

    \;
  </scm-chunk>

  <paragraph|string-every><index|string-every>

  <scm|string-every>是一个谓词函数，它接收一个字符串<scm|str>和一个评估规则<scm|criterion>为参数，以及最多2个非负整数为可选参数<scm|. start_end>用于指定搜索的起始位置和结束位置，检查指定范围内字符串中的每个字符是否都满足评估规则<scm|criterion>。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-every char/pred? str . start+end)

    \ \ (define (string-every-sub pred? str)

    \ \ \ \ (let

    \ \ \ \ \ \ loop ((i 0) (len (string-length str)))

    \ \ \ \ \ \ (or (= i len)

    \ \ \ \ \ \ \ \ \ \ (and (pred? (string-ref str i))\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) len)))))

    \ \ 

    \ \ (let ((str-sub (%string-from-range str start+end))

    \ \ \ \ \ \ \ \ (criterion (%make-criterion char/pred?)))

    \ \ \ \ (string-every-sub criterion str-sub)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check-true (string-every #\\x "xxxxxx"))

    (check-false (string-every #\\x "xxx0xx"))

    \;

    (check

    \ \ (string-every\ 

    \ \ \ \ char-numeric?

    \ \ \ \ "012345")

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (string-every\ 

    \ \ \ \ char-numeric?

    \ \ \ \ "012d45")

    \ \ =\<gtr\>

    \ \ #f)

    \;
  </scm-chunk>

  注意，评估规则<scm|criterion>必须是谓词或字符，否则报错。

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-every

    \ \ \ \ \ \ \ \ \ 1

    \ \ \ \ \ \ \ \ \ "012345"))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-every

    \ \ \ \ \ \ \ \ \ #\\012345

    \ \ \ \ \ \ \ \ \ "012345"))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-every

    \ \ \ \ \ \ \ \ \ "012345"

    \ \ \ \ \ \ \ \ \ "012345"))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  注意，谓词要使用字符属性测试函数（例如<scm|char-numeric?>），不要用类型检查函数（例如<scm|<code*|number?>>），否则失去了检查的意义。

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check

    \ \ (string-every\ 

    \ \ \ \ char-numeric?

    \ \ \ \ "012345")

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (string-every\ 

    \ \ \ \ <code*|number?>

    \ \ \ \ "012345")

    \ \ =\<gtr\>

    \ \ #f)

    \;
  </scm-chunk>

  对于可选参数<scm|. start_end>：没有可选参数时，默认搜索整个字符串；只有1个可选参数时，该数指定的是起始位置，结束位置默认为字符串的最后一个字符。注意，有2个可选参数时，第二个数不能小于第一个数，否则报错；指定的起始位置和结束位置不能超过字符串<scm|str>的起始范围，否则报错；可选参数超过2个时，报错。（注意，可选参数的规则适用于后面所有调用到<scm|%string-from-range>的函数）

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check-true (string-every char-numeric? "ab2345" 2))

    \;

    (check-false (string-every char-numeric? "ab2345" 1))

    \;

    (check

    \ \ (string-every\ 

    \ \ \ \ char-numeric?

    \ \ \ \ "ab234f"

    \ \ \ \ 2)

    \ \ =\<gtr\>

    \ \ #f)

    \;

    (check

    \ \ (string-every\ 

    \ \ \ \ char-numeric?

    \ \ \ \ "ab234f"

    \ \ \ \ 2

    \ \ \ \ 4)

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (string-every\ 

    \ \ \ \ <code*|char-numeric?>

    \ \ \ \ "ab234f"

    \ \ \ \ 2

    \ \ \ \ 2)

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (string-every\ 

    \ \ \ \ <code*|char-numeric?>

    \ \ \ \ "ab234f"

    \ \ \ \ 1

    \ \ \ \ 4)

    \ \ =\<gtr\>

    \ \ #f)

    \;

    (check

    \ \ (string-every\ 

    \ \ \ \ char-numeric?

    \ \ \ \ "ab234f"

    \ \ \ \ 2

    \ \ \ \ 5)

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (string-every\ 

    \ \ \ \ <code*|char-numeric?>

    \ \ \ \ "ab234f"

    \ \ \ \ 2

    \ \ \ \ 6)

    \ \ =\<gtr\>

    \ \ #f)

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-every\ 

    \ \ \ \ \ \ \ \ char-numeric?

    \ \ \ \ \ \ \ "ab234f"

    \ \ \ \ \ \ \ 2

    \ \ \ \ \ \ \ 7))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-every\ 

    \ \ \ \ \ \ \ \ char-numeric?

    \ \ \ \ \ \ \ "ab234f"

    \ \ \ \ \ \ \ 2

    \ \ \ \ \ \ \ 1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'wrong-number-of-args

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-every\ 

    \ \ \ \ \ \ \ \ char-numeric?

    \ \ \ \ \ \ \ "ab234f"

    \ \ \ \ \ \ \ 2

    \ \ \ \ \ \ \ 7

    \ \ \ \ \ \ \ 1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <paragraph|string-any><index|string-any>

  <scm|string-any>是一个谓词函数，它接收一个谓词和一个字符串为参数，用于检查字符串中是否存在字符都满足谓词。注意，这里的谓词必须是字符属性测试函数，否则报错。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-any char/pred? str . start+end)

    \ \ (define (string-any-sub pred? str)

    \ \ \ \ (let

    \ \ \ \ \ \ loop ((i 0) (len (string-length str)))

    \ \ \ \ \ \ (if (= i len)

    \ \ \ \ \ \ \ \ \ \ #f \ \ 

    \ \ \ \ \ \ \ \ \ \ (or (pred? (string-ref str i))\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) len)))))

    \ \ 

    \ \ (let ((str_sub (%string-from-range str start+end))

    \ \ \ \ \ \ \ \ (criterion (%make-criterion char/pred?)))

    \ \ \ \ (string-any-sub criterion str_sub)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check-true (string-any #\\0 "xxx0xx"))

    (check-false (string-any #\\0 "xxxxxx"))

    \;

    (check

    \ \ (string-any\ 

    \ \ \ \ char-numeric?

    \ \ \ \ "xxx0xx")

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (string-any

    \ \ \ \ char-numeric?

    \ \ \ \ "xxxxxx")

    \ \ =\<gtr\>

    \ \ #f)

    \;
  </scm-chunk>

  注意，评估规则<scm|criterion>必须是谓词或字符，否则报错。

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-every

    \ \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ \ "xxx0xx"))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-any

    \ \ \ \ \ \ \ \ \ (lambda (n) (= n 0))

    \ \ \ \ \ \ \ \ \ "xxx0xx"))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-every

    \ \ \ \ \ \ \ \ \ "0"

    \ \ \ \ \ \ \ \ \ "xxx0xx"))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  对于可选参数：

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check-true (string-any char-alphabetic? "01c345" 2))

    \;

    (check-false (string-any char-alphabetic? "01c345" 3))

    \;

    (check

    \ \ (string-any\ 

    \ \ \ \ <code*|char-alphabetic?>

    \ \ \ \ "01c345"

    \ \ \ \ 2

    \ \ \ \ 4)

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (string-any\ 

    \ \ \ \ <code*|char-alphabetic?>

    \ \ \ \ "01c345"

    \ \ \ \ 2

    \ \ \ \ 2)

    \ \ =\<gtr\>

    \ \ #f)

    \;

    (check

    \ \ (string-any\ 

    \ \ \ \ <code*|char-alphabetic?>

    \ \ \ \ "01c345"

    \ \ \ \ 3

    \ \ \ \ 4)

    \ \ =\<gtr\>

    \ \ #f)

    \;

    (check

    \ \ (string-any\ 

    \ \ \ \ char-alphabetic?

    \ \ \ \ "01c345"

    \ \ \ \ 2

    \ \ \ \ 6)

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-any\ 

    \ \ \ \ \ \ \ \ \ char-alphabetic?

    \ \ \ \ \ \ \ \ "01c345"

    \ \ \ \ \ \ \ \ 2

    \ \ \ \ \ \ \ \ 7))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-any\ 

    \ \ \ \ \ \ \ \ \ char-alphabetic?

    \ \ \ \ \ \ \ \ "01c345"

    \ \ \ \ \ \ \ 2

    \ \ \ \ \ \ \ 1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'wrong-number-of-args

    \ \ \ \ (lambda ()\ 

    \ \ \ \ \ \ (string-any\ 

    \ \ \ \ \ \ \ \ \ char-alphabetic?

    \ \ \ \ \ \ \ \ "01c345"

    \ \ \ \ \ \ \ 2

    \ \ \ \ \ \ \ 7

    \ \ \ \ \ \ \ 1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <section|选择器>

  <label|r7rs><paragraph|string-length><index|string-length>

  <scm|string-length>是一个S7内置的函数，它接收一个字符串作为参数，返回一个表示该字符串长度的整数，即字符串中包含的字符数。当参数不是字符串，报错。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (string-length "MathAgape") =\<gtr\> 9)

    (check (string-length "") =\<gtr\> 0)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (string-length 'not-a-string))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <label|r7rs><paragraph|string-ref><index|string-ref>

  <scm|string-ref>是一个S7内置的函数，接收一个字符串和一个称为索引值的非负整数k为参数，通过索引值k返回字符串的第k个元素（从0开始计数）。当参数为空字符串时，报错。当k为负数，报错。当k大于等于字符串中字符数时，报错。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (string-ref "MathAgape" 0) =\<gtr\> #\\M)

    (check (string-ref "MathAgape" 2) =\<gtr\> #\\t)

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (string-ref "MathAgape" -1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (string-ref "MathAgape" 9))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (string-ref "" 0))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <label|r7rs><paragraph|string-copy><index|string-copy>

  <scm|string-copy>是一个S7内置的函数，用于创建一个现有字符串的副本。这个函数返回一个与原始字符串内容完全相同的新字符串，但它们在内存中是两个独立的实体。也就是说，原始字符串和副本字符串内容相同，但它们是不同的对象，这可以用<code|<code*|equal?>>和<code|<code*|eq?>>对比出来。

  <scm|string-copy>和<scm|%string-from-range>的实现比较接近，区别在于：在没有指定字符串的范围的时候，我们需要使用<scm|substring>来模拟整个字符串的拷贝。S7内置的函数只提供了整个字符串的拷贝，R7RS和SRFI-13是需要额外的字符串的范围的，所以需要重新实现。

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (string-copy str . start_end)

    \ \ (cond ((null? start_end)

    \ \ \ \ \ \ \ \ \ (substring str 0))

    \ \ \ \ \ \ \ \ ((= (length start_end) 1)

    \ \ \ \ \ \ \ \ \ \ (substring str (car start_end)))

    \ \ \ \ \ \ \ \ ((= (length start_end) 2)

    \ \ \ \ \ \ \ \ \ (substring str (car start_end) (cadr start_end)))

    \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (define original-string "MathAgape")

    (define copied-string (string-copy original-string))

    \;

    (check-true (equal? original-string copied-string))

    (check-false (eq? original-string copied-string))

    \;

    (check-true

    \ \ (equal? (string-copy "MathAgape" 4)

    \ \ \ \ \ \ \ \ \ \ (string-copy "MathAgape" 4)))

    \;

    (check-false

    \ \ (eq? (string-copy "MathAgape" 4)

    \ \ \ \ \ \ \ (string-copy "MathAgape" 4)))

    \;

    (check-true

    \ \ (equal? (string-copy "MathAgape" 4 9)

    \ \ \ \ \ \ \ \ \ \ (string-copy "MathAgape" 4 9)))

    \;

    (check-false

    \ \ (eq? (string-copy "MathAgape" 4 9)

    \ \ \ \ \ \ \ (string-copy "MathAgape" 4 9)))

    \;
  </scm-chunk>

  \;

  <paragraph|string-take><index|string-take>

  <scm|string-take>是一个函数，接收一个字符串和一个非负整数k为参数，返回字符串的前k个字符组成的新字符串。当字符串字符数量不足k个，报错。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-take str k)

    \ \ (list-\<gtr\>string (take (string-\<gtr\>list str) k)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-take "MathAgape" 4) =\<gtr\> "Math")

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (string-take "MathAgape" 20))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <paragraph|string-take-right><index|string-take-right>

  <scm|string-take-right>是一个函数，接收一个字符串和一个非负整数k为参数，取出字符串的后k个字符组成新字符串，返回这个新字符串。当字符串字符数量不足k个，报错。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-take-right str k)

    \ \ (list-\<gtr\>string (take-right (string-\<gtr\>list str) k)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-take-right "MathAgape" 1) =\<gtr\> "e")

    \;

    (check-catch 'wrong-type-arg (string-take-right "MathAgape" 20))

    \;
  </scm-chunk>

  <paragraph|string-drop><index|string-drop>

  <scm|string-drop>是一个函数，接收一个字符串和一个非负整数k为参数，返回去掉字符串前k个字符组成的新字符串。当字符串字符数量不足k个，报错。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-drop str k)

    \ \ (list-\<gtr\>string (drop (string-\<gtr\>list str) k)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-drop "MathAgape" 8) =\<gtr\> "e")

    \;

    (check-catch 'wrong-type-arg (string-drop "MathAgape" 20))

    \;
  </scm-chunk>

  <paragraph|string-drop-right><index|string-drop-right><scm|(str k) =\<gtr\> string>

  <scm|string-drop-right>是一个函数，接收一个字符串和一个非负整数k为参数，去掉字符串的后k个字符组成新字符串，返回这个新字符串。当字符串字符数量不足k个，报错。当k为负数，报错。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-drop-right str k)

    \ \ (list-\<gtr\>string (drop-right (string-\<gtr\>list str) k)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-drop-right "MathAgape" 5) =\<gtr\> "Math")

    \;

    (check-catch 'wrong-type-arg (string-drop "MathAgape" 20))

    \;
  </scm-chunk>

  <paragraph|string-pad><index|string-pad>

  <scm|string-pad>是一个函数，接收一个字符串、一个指定长度（非负整数）为参数，从左填充空格字符直到指定长度，返回这个新字符。当指定长度等于字符串长度，返回的字符串和原字符串内容相同。当指定长度小于字符串长度，则从左去掉字符直到指定长度，返回这个新字符。当参数的指定长度为负数时，报错。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-pad str len . char+start+end)

    \ \ (define (string-pad-sub str len ch)

    \ \ \ \ (let ((orig-len (string-length str)))

    \ \ \ \ \ \ (if (\<less\> len orig-len)

    \ \ \ \ \ \ \ \ \ \ (string-take-right str len)

    \ \ \ \ \ \ \ \ \ \ (string-append (make-string (- len orig-len) ch) str))))

    \ \ 

    \ \ (cond ((null-list? char+start+end)

    \ \ \ \ \ \ \ \ \ (string-pad-sub str len #\\ ))

    \ \ \ \ \ \ \ \ ((list? char+start+end)

    \ \ \ \ \ \ \ \ \ (string-pad-sub

    \ \ \ \ \ \ \ \ \ \ \ (%string-from-range str (cdr char+start+end))

    \ \ \ \ \ \ \ \ \ \ \ len

    \ \ \ \ \ \ \ \ \ \ \ (car char+start+end)))

    \ \ \ \ \ \ \ \ (else (error 'wrong-type-arg "string-pad"))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check

    \ \ (string-pad "MathAgape" 15)

    \ \ =\<gtr\>

    \ \ " \ \ \ \ \ MathAgape")

    \;

    (check

    \ \ (string-pad "MathAgape" 12 #\\1)

    \ \ =\<gtr\>

    \ \ "111MathAgape")

    \;

    (check

    \ \ (string-pad "MathAgape" 6 #\\1 0 4)

    \ \ =\<gtr\>

    \ \ "11Math")

    \;

    (check

    \ \ (string-pad "MathAgape" 9)

    \ \ =\<gtr\>

    \ \ "MathAgape")

    \;

    (check

    \ \ (string-pad "MathAgape" 5)

    \ \ =\<gtr\>

    \ \ "Agape")

    \;

    (check

    \ \ (string-pad "MathAgape" 2 #\\1 0 4)

    \ \ =\<gtr\>

    \ \ "th")

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (string-pad "MathAgape" -1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <paragraph|string-pad-right><index|string-pad-right>

  <scm|string-pad-right>是一个函数，接收一个字符串、一个指定长度（非负整数）为参数，从右填充空格字符直到指定长度，返回这个新字符。当指定长度等于字符串长度，返回的字符串和原字符串内容相同。当指定长度小于字符串长度，则从右去掉字符直到指定长度，返回这个新字符。当参数的指定长度为负数时，报错。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-pad-right str len . char+start+end)

    \ \ (define (string-pad-right-sub str len ch)

    \ \ \ \ (let ((orig-len (string-length str)))

    \ \ \ \ \ \ (if (\<less\> len orig-len)

    \ \ \ \ \ \ \ \ \ \ (string-take str len)

    \ \ \ \ \ \ \ \ \ \ (string-append str (make-string (- len orig-len) ch)))))

    \ \ 

    \ \ (cond ((null-list? char+start+end)

    \ \ \ \ \ \ \ \ \ (string-pad-right-sub str len #\\ ))

    \ \ \ \ \ \ \ \ ((list? char+start+end)

    \ \ \ \ \ \ \ \ \ (string-pad-right-sub

    \ \ \ \ \ \ \ \ \ \ \ (%string-from-range str (cdr char+start+end))

    \ \ \ \ \ \ \ \ \ \ \ len

    \ \ \ \ \ \ \ \ \ \ \ (car char+start+end)))

    \ \ \ \ \ \ \ \ (else (error 'wrong-type-arg "string-pad"))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-pad-right "MathAgape" 15) =\<gtr\> "MathAgape \ \ \ \ \ ")

    \;

    (check (string-pad-right "MathAgape" 12 #\\1) =\<gtr\> "MathAgape111")

    \;

    (check

    \ \ (string-pad-right "MathAgape" 6 #\\1 0 4)

    \ \ =\<gtr\>

    \ \ "Math11")

    \;

    (check

    \ \ (string-pad-right "MathAgape" 9)

    \ \ =\<gtr\>

    \ \ "MathAgape")

    \;

    (check

    \ \ (string-pad-right "MathAgape" 9 #\\1)

    \ \ =\<gtr\>

    \ \ "MathAgape")

    \;

    (check

    \ \ (string-pad-right "MathAgape" 4)

    \ \ =\<gtr\>

    \ \ "Math")

    \;

    (check

    \ \ (string-pad "MathAgape" 2 #\\1 0 4)

    \ \ =\<gtr\>

    \ \ "th")

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (string-pad-right "MathAgape" -1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <paragraph|string-trim><index|string-trim>

  <scm|string-trim>是一个函数，用于去除字符串左端的空白字符。空白字符通常包括空格、制表符、换行符等。当原字符串只包含空白字符，返回空字符串。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (%trim-do str string-trim-sub criterion+start+end)

    \ \ (cond ((null-list? criterion+start+end)

    \ \ \ \ \ \ \ \ \ (string-trim-sub str #\\ ))

    \ \ \ \ \ \ \ \ ((list? criterion+start+end)

    \ \ \ \ \ \ \ \ \ (if (char? (car criterion+start+end))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (string-trim-sub

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (%string-from-range str (cdr criterion+start+end))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car criterion+start+end))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (string-trim-sub

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (%string-from-range str criterion+start+end)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ #\\ )))

    \ \ \ \ \ \ \ \ (else (error 'wrong-type-arg "string-trim"))))

    \;

    (define (string-trim str . criterion+start+end)

    \ \ (define (string-trim-sub str space-or-char)

    \ \ \ \ (let loop ((i 0)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (len (string-length str)))

    \ \ \ \ \ \ \ \ \ (if (or (= i len) (not (char=? space-or-char (string-ref str i))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (substring str i len)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) len))))

    \ \ (%trim-do str string-trim-sub criterion+start+end))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-trim " \ 2 4 \ ") =\<gtr\> "2 4 \ ")

    (check (string-trim " \ 2 4 \ " 2) =\<gtr\> "2 4 \ ")

    (check (string-trim " \ 2 4 \ " 3) =\<gtr\> "4 \ ")

    (check (string-trim " \ 2 4 \ " 4) =\<gtr\> "4 \ ")

    (check (string-trim " \ 2 4 \ " 5) =\<gtr\> "")

    \;

    (check-catch 'out-of-range (string-trim " \ 2 4 \ " 8))

    \;

    (check

    \ \ (string-trim " \ 2 4 \ " 0 4)

    \ \ =\<gtr\>

    \ \ "2 ")

    \;

    (check

    \ \ (string-trim " \ 2 4 \ " 0 7)

    \ \ =\<gtr\>

    \ \ "2 4 \ ")

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (string-trim " \ 2 4 \ " 0 8))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (string-trim " \ 2 4 \ " #\\ )

    \ \ =\<gtr\>

    \ \ "2 4 \ ")

    \;

    (check

    \ \ (string-trim "-- 2 4 --" #\\-)

    \ \ =\<gtr\>

    \ \ " 2 4 --")

    \;

    (check

    \ \ (string-trim " - 345" #\\- 1)

    \ \ =\<gtr\>

    \ \ " 345")

    \;

    (check

    \ \ (string-trim " - 345" #\\- 1 4)

    \ \ =\<gtr\>

    \ \ " 3")

    \;
  </scm-chunk>

  <paragraph|string-trim-right><index|string-trim-right>

  <scm|string-trim-right>是一个函数，用于去除字符串右端的空白字符。当原字符串只包含空白字符，返回空字符串。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-trim-right str . criterion+start+end)

    \ \ (define (string-trim-right-sub str space-or-char)

    \ \ \ \ (let loop ((i (- (string-length str) 1)))

    \ \ \ \ \ \ (cond ((negative? i) "")

    \ \ \ \ \ \ \ \ \ \ \ \ ((char=? space-or-char (string-ref str i)) (loop (- i 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ (else (substring str 0 (+ i 1))))))

    \ \ (%trim-do str string-trim-right-sub criterion+start+end))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-trim-right " \ 2 4 \ ") =\<gtr\> " \ 2 4")

    \;

    (check

    \ \ (string-trim-right " \ 2 4 \ " 1)

    \ \ =\<gtr\>

    \ \ " 2 4")

    \;

    (check

    \ \ (string-trim-right " \ 2 4 \ " 2)

    \ \ =\<gtr\>

    \ \ "2 4")

    \;

    (check

    \ \ (string-trim-right " \ 2 4 \ " 3)

    \ \ =\<gtr\>

    \ \ " 4")

    \;

    (check

    \ \ (string-trim-right " \ 2 4 \ " 4)

    \ \ =\<gtr\>

    \ \ "4")

    \;

    (check

    \ \ (string-trim-right " \ 2 4 \ " 5)

    \ \ =\<gtr\>

    \ \ "")

    \;

    (check

    \ \ (string-trim-right " \ 2 4 \ " 6)

    \ \ =\<gtr\>

    \ \ "")

    \;

    (check

    \ \ (string-trim-right " \ 2 4 \ " 7)

    \ \ =\<gtr\>

    \ \ "")

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (string-trim-right " \ 2 4 \ " 8))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check (string-trim-right " \ 2 4 \ " 0 4) =\<gtr\> " \ 2")

    (check (string-trim-right " \ 2 4 \ " 0 7) =\<gtr\> " \ 2 4")

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (string-trim-right " \ 2 4 \ " 0 8))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check (string-trim-right " \ 2 4 \ " #\\ ) =\<gtr\> " \ 2 4")

    (check (string-trim-right "-- 2 4 --" #\\-) =\<gtr\> "-- 2 4 ")

    (check (string-trim-right "012-" #\\- 1) =\<gtr\> "12")

    (check (string-trim-right "012-4" #\\- 0 4) =\<gtr\> "012")

    \;
  </scm-chunk>

  <paragraph|string-trim-both><index|string-trim-both>

  <scm|string-trim-both>是一个函数，用于去除字符串两端的空白字符。当原字符串只包含空白字符，报错。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-trim-both str . criterion+start+end)

    \ \ (define (string-trim-both-sub str space-or-char)

    \ \ \ \ (let loop ((i 0)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (len (string-length str)))

    \ \ \ \ (if (or (= i len) (not (char=? space-or-char (string-ref str i))))

    \ \ \ \ \ \ \ \ (let loop-end ((j (- len 1)))

    \ \ \ \ \ \ \ \ \ \ (if (or (\<less\> j 0) (not (char=? space-or-char (string-ref str j))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (substring str i (+ j 1))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop-end (- j 1))))

    \ \ \ \ \ \ \ \ (loop (+ i 1) len))))

    \ \ (%trim-do str string-trim-both-sub criterion+start+end))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-trim-both " \ 2 4 \ ") =\<gtr\> "2 4")

    (check (string-trim-both "--2 4--" #\\-) =\<gtr\> "2 4")

    \;
  </scm-chunk>

  <section|前缀和后缀>

  <paragraph|string-prefix?><index|string-prefix?>

  <scm|string-prefix?>是一个谓词函数，用于检查一个字符串是否是另一个字符串的前缀。若第一个字符串是第二个字符串的前缀，则函数返回<scm|#t>；否则返回<scm|#f>。特别地，空字符串是任意字符串的前缀；两个内容相同的字符串互为前缀。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-prefix? prefix str)

    \ \ (let* ((prefix-len (string-length prefix))

    \ \ \ \ \ \ \ \ \ (str-len (string-length str)))

    \ \ \ \ (and (\<less\>= prefix-len str-len)

    \ \ \ \ \ \ \ \ \ (let loop ((i 0))

    \ \ \ \ \ \ \ \ \ \ \ (or (= i prefix-len)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (and (char=? (string-ref prefix i)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (string-ref str i))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1))))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check-true (string-prefix? "Ma" "MathAgape"))

    (check-true (string-prefix? "" "MathAgape"))

    (check-true (string-prefix? "MathAgape" "MathAgape"))

    (check-false (string-prefix? "a" "MathAgape"))

    \;
  </scm-chunk>

  <paragraph|string-suffix?><index|string-suffix?>

  <scm|string-suffix?>是一个谓词函数，用于检查一个字符串是否是另一个字符串的后缀。若第一个字符串是第二个字符串的后缀，则函数返回<scm|#t>；否则返回<scm|#f>。特别地，空字符串是任意字符串的后缀；两个内容相同的字符串互为后缀。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-suffix? suffix str)

    \ \ (let* ((suffix-len (string-length suffix))

    \ \ \ \ \ \ \ \ \ (str-len (string-length str)))

    \ \ \ \ (and (\<less\>= suffix-len str-len)

    \ \ \ \ \ \ \ \ \ (let loop ((i 0)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (j (- str-len suffix-len)))

    \ \ \ \ \ \ \ \ \ \ \ (or (= i suffix-len)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (and (char=? (string-ref suffix i)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (string-ref str j))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) (+ j 1))))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check-true (string-suffix? "e" "MathAgape"))

    (check-true (string-suffix? "" "MathAgape"))

    (check-true (string-suffix? "MathAgape" "MathAgape"))

    (check-false (string-suffix? "p" "MathAgape"))

    \;
  </scm-chunk>

  <section|搜索>

  <paragraph|string-index><index|string-index>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-index str char/pred? . start+end)

    \ \ (define (string-index-sub str pred?)

    \ \ \ \ (let loop ((i 0))

    \ \ \ \ \ \ (cond ((\<gtr\>= i (string-length str)) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ ((pred? (string-ref str i)) i)

    \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (+ i 1))))))

    \ \ 

    \ \ (let* ((start (if (null-list? start+end) 0 (car start+end)))

    \ \ \ \ \ \ \ \ \ (str-sub (%string-from-range str start+end))

    \ \ \ \ \ \ \ \ \ (pred? (%make-criterion char/pred?))

    \ \ \ \ \ \ \ \ \ (ret (string-index-sub str-sub pred?)))

    \ \ \ \ (if ret (+ start ret) ret)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-index "0123456789" #\\2) =\<gtr\> 2)

    (check (string-index "0123456789" #\\2 2) =\<gtr\> 2)

    (check (string-index "0123456789" #\\2 3) =\<gtr\> #f)

    (check (string-index "01x3456789" char-alphabetic?) =\<gtr\> 2)

    \;
  </scm-chunk>

  <paragraph|string-index-right><index|string-index-right>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-index-right str char/pred? . start+end)

    \ \ (define (string-index-right-sub str pred?)

    \ \ \ \ (let loop ((i (- (string-length str) 1)))

    \ \ \ \ \ \ (cond ((\<less\> i 0) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ ((pred? (string-ref str i)) i)

    \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (- i 1))))))

    \ \ 

    \ \ (let* ((start (if (null-list? start+end) 0 (car start+end)))

    \ \ \ \ \ \ \ \ (str-sub (%string-from-range str start+end))

    \ \ \ \ \ \ \ \ (pred? (%make-criterion char/pred?))

    \ \ \ \ \ \ \ \ (ret (string-index-right-sub str-sub pred?)))

    \ \ \ \ (if ret (+ start ret) ret)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-index-right "0123456789" #\\8) =\<gtr\> 8)

    (check (string-index-right "0123456789" #\\8 2) =\<gtr\> 8)

    (check (string-index-right "0123456789" #\\8 9) =\<gtr\> #f)

    (check (string-index-right "01234567x9" char-alphabetic?) =\<gtr\> 8)

    \;
  </scm-chunk>

  <paragraph|string-contains><index|string-contains>

  <scm|string-contains>是一个函数，用于检查一个字符串是否包含另一个子字符串，包含则返回<scm|#t>，返回<scm|#f>。

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-contains str sub-str)

    \ \ (let loop ((i 0))

    \ \ \ \ (let ((len (string-length str))

    \ \ \ \ \ \ \ \ \ \ (sub-str-len (string-length sub-str)))

    \ \ \ \ \ \ (if (\<gtr\> i (- len sub-str-len))\ 

    \ \ \ \ \ \ \ \ \ \ #f

    \ \ \ \ \ \ \ \ \ \ (if (string=?\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (substring

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ str

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (+ i sub-str-len))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sub-str)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ #t

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1)))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check-true (string-contains "0123456789" "3"))

    (check-true (string-contains "0123456789" "34"))

    (check-false (string-contains "0123456789" "24"))

    \;
  </scm-chunk>

  <paragraph|string-count><index|string-count>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-count str char/pred? . start+end)

    \ \ (let ((str-sub (%string-from-range str start+end))

    \ \ \ \ \ \ \ \ (criterion (%make-criterion char/pred?)))

    \ \ \ \ (count criterion (string-\<gtr\>list str-sub))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-count "xyz" #\\x) =\<gtr\> 1)

    (check (string-count "xyz" #\\x 0 1) =\<gtr\> 1)

    (check (string-count "xyz" #\\y 0 1) =\<gtr\> 0)

    (check (string-count "xyz" #\\x 0 3) =\<gtr\> 1)

    (check (string-count "xyz" (lambda (x) (char=? x #\\x))) =\<gtr\> 1)

    \;
  </scm-chunk>

  <section|翻转和追加>

  <paragraph|string-reverse><index|string-reverse>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-reverse str . start+end)

    \ \ (cond ((null-list? start+end)

    \ \ \ \ \ \ \ \ \ (reverse str))

    \ \ \ \ \ \ \ \ ((= (length start+end) 1)

    \ \ \ \ \ \ \ \ \ (let ((start (first start+end)))

    \ \ \ \ \ \ \ \ \ \ \ (string-append (substring str 0 start)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (reverse (substring str start)))))

    \ \ \ \ \ \ \ \ ((= (length start+end) 2)

    \ \ \ \ \ \ \ \ \ (let ((start (first start+end))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (end (second start+end)))

    \ \ \ \ \ \ \ \ \ \ \ (string-append (substring str 0 start)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (reverse (substring str start end))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (substring str end))))

    \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args "string-reverse"))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check (string-reverse "01234") =\<gtr\> "43210")

    \;

    (check-catch 'out-of-range (string-reverse "01234" -1))

    \;

    (check (string-reverse "01234" 0) =\<gtr\> "43210")

    (check (string-reverse "01234" 1) =\<gtr\> "04321")

    (check (string-reverse "01234" 5) =\<gtr\> "01234")

    \;

    (check-catch 'out-of-range (string-reverse "01234" 6))

    \;

    (check (string-reverse "01234" 0 2) =\<gtr\> "10234")

    (check (string-reverse "01234" 1 3) =\<gtr\> "02134")

    (check (string-reverse "01234" 1 5) =\<gtr\> "04321")

    (check (string-reverse "01234" 0 5) =\<gtr\> "43210")

    \;

    (check-catch 'out-of-range (string-reverse "01234" 1 6))

    \;

    (check-catch 'out-of-range (string-reverse "01234" -1 3))

    \;
  </scm-chunk>

  \;

  <label|r7rs><paragraph|string-append><index|string-append>

  <scm|string-append>是一个S7内置的函数，用于连接两个或多个字符串。它会将所有提供的字符串参数逐个拼接在一起，并返回一个新的字符串，原始字符串不会被修改。当没有参数时，返回空字符串。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (string-append "Math" "Agape") =\<gtr\> "MathAgape")

    \;

    (check (string-append) =\<gtr\> "")

    \;
  </scm-chunk>

  <section|Fold, unfold & map>

  <label|r7rs><paragraph|string-map><index|string-map>

  <subparagraph|实现>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (string-map p . args) (apply string (apply map p args)))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check

    \ \ (string-map

    \ \ \ \ (lambda (ch) (integer-\<gtr\>char (+ 1 (char-\<gtr\>integer ch))))

    \ \ \ \ "HAL")

    \ \ =\<gtr\> "IBM")

    \;
  </scm-chunk>

  \;

  <label|r7rs><paragraph|string-for-each><scm|(proc str1 [str2 ...])><index|string-for-each>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define string-for-each for-each)

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check

    \ \ (let ((lst '()))

    \ \ \ \ (string-for-each

    \ \ \ \ \ \ (lambda (x) (set! lst (cons (char-\<gtr\>integer x) lst)))

    \ \ \ \ \ \ "12345")

    \ \ \ \ lst)

    \ \ =\<gtr\> '(53 52 51 50 49))

    \;

    (check

    \ \ (let ((lst '()))

    \ \ \ \ (string-for-each

    \ \ \ \ \ \ (lambda (x) (set! lst (cons (- (char-\<gtr\>integer x) (char-\<gtr\>integer #\\0)) lst)))

    \ \ \ \ \ \ "12345")

    \ \ \ \ lst)

    \ \ =\<gtr\> '(5 4 3 2 1))

    \;

    (check

    \ \ (let ((lst '()))

    \ \ \ \ (string-for-each

    \ \ \ \ \ \ (lambda (x) (set! lst (cons (- (char-\<gtr\>integer x) (char-\<gtr\>integer #\\0)) lst)))

    \ \ \ \ \ \ "123")

    \ \ \ \ lst)

    \ \ =\<gtr\> '(3 2 1))

    \;

    (check

    \ \ (let ((lst '()))

    \ \ \ \ (string-for-each

    \ \ \ \ \ \ (lambda (x) (set! lst (cons (- (char-\<gtr\>integer x) (char-\<gtr\>integer #\\0)) lst)))

    \ \ \ \ \ \ "")

    \ \ \ \ lst)

    \ \ =\<gtr\> '())

    \;
  </scm-chunk>

  <section|插入和解析>

  <paragraph|string-tokenize><index|string-tokenize>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|true>
    (define (string-tokenize str . char+start+end)

    \ \ 

    \ \ (define (string-tokenize-sub str char)

    \ \ \ \ 

    \ \ \ \ (define (tokenize-helper tokens cursor)

    \ \ \ \ \ \ (let ((sep-pos/false (string-index str char cursor)))

    \ \ \ \ \ \ \ \ (if (not sep-pos/false)

    \ \ \ \ \ \ \ \ \ \ \ \ (reverse (cons (substring str cursor) tokens))

    \ \ \ \ \ \ \ \ \ \ \ \ (let ((new-tokens

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (= cursor sep-pos/false)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tokens

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons (substring str cursor sep-pos/false) tokens)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (next-cursor (+ sep-pos/false 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (tokenize-helper new-tokens next-cursor)))))

    \ \ 

    \ \ \ \ \ \ (tokenize-helper '() 0))

    \ \ 

    \ \ (cond ((null-list? char+start+end)

    \ \ \ \ \ \ \ \ \ (string-tokenize-sub str #\\ ))

    \ \ \ \ \ \ \ \ ((list? char+start+end)

    \ \ \ \ \ \ \ \ \ (string-tokenize-sub

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (%string-from-range str (cdr char+start+end))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car char+start+end)))

    \ \ \ \ \ \ \ \ (else (error 'wrong-type-arg "string-tokenize"))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|true>
    (check

    \ \ (string-tokenize "1 22 333")

    \ \ =\<gtr\> '("1" "22" "333"))

    \;

    (check

    \ \ (string-tokenize "1 22 333" #\\2)

    \ \ =\<gtr\> '("1 " " 333"))

    \;

    (check

    \ \ (string-tokenize "1 22 333" #\\ \ 2)

    \ \ =\<gtr\> ‘("22" "333"))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/srfi/srfi-13.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/string-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii list)><label|chapter:liii_list>

  <section|许可证>

  <\scm-chunk|goldfish/liii/list.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|false|true>
    ;;; SRFI-1 list-processing library \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -*- Scheme -*-

    ;;; Reference implementation

    ;;;

    ;;; SPDX-License-Identifier: MIT

    ;;;

    ;;; Copyright (c) 1998, 1999 by Olin Shivers. You may do as you please with

    ;;; this code as long as you do not remove this copyright notice or

    ;;; hold me liable for its use. Please send bug reports to shivers@ai.mit.edu.

    ;;; \ \ \ \ -Olin

    ;;;

    ;;; Copyright (c) 2024 The Goldfish Scheme Authors

    ;;; Follow the same License as the original one

    \;
  </scm-chunk>

  <section|接口>

  Liii List函数库是金鱼标准库中的List函数库，其中的大部分函数来自函数库<scm|(srfi srfi-1)>，小部分是三鲤自己设计的函数。来自SRFI 1的，我们只是在Liii List中导出相关函数名，相关实现和单元测试都在SRFI 1中维护。

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define-library (liii list)

    (export

    \ \ ; S7 built-in

    \ \ cons car cdr map for-each

    \ \ ; SRFI 1: Constructors

    \ \ circular-list iota

    \ \ ; SRFI 1: Predicates

    \ \ null-list? circular-list?

    \ \ ; SRFI 1: Selectors

    \ \ first second third fourth fifth sixth seventh eighth ninth tenth

    \ \ take drop take-right drop-right

    \ \ last-pair last

    \ \ ; SRFI 1: fold, unfold & map

    \ \ count fold fold-right reduce reduce-right

    \ \ filter partition remove

    \ \ ; SRFI 1: Searching

    \ \ find any every list-index

    \ \ take-while drop-while

    \ \ ; SRFI 1: deleting

    \ \ delete

    \ \ ; Liii List extensions

    \ \ list-view flatmap

    \ \ list-null? list-not-null? not-null-list?

    \ \ length=?

    )

    (import (srfi srfi-1)

    \ \ \ \ \ \ \ \ (liii error))

    (begin

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define-library (srfi srfi-1)

    (import (liii error))

    (export

    \ \ circular-list iota circular-list? null-list?

    \ \ first second third fourth fifth

    \ \ sixth seventh eighth ninth tenth

    \ \ take drop take-right drop-right count fold fold-right

    \ \ reduce reduce-right filter partition remove find

    \ \ delete delete-duplicates

    \ \ take-while drop-while list-index any every

    \ \ last-pair last)

    (begin

    \;
  </scm-chunk>

  <section|测试>

  在金鱼Scheme中的SRFI 1实现需要遵循最小依赖原则，目前<scm|delete-duplicates>是一个复杂度比较高的实现，在SRFI 1中保留，但并不在<scm|(liii list)>导出，故而在本测试文件的开头需要从<scm|(srfi srfi-1)>单独导入。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (import (liii list)

    \ \ \ \ \ \ \ \ (liii check)

    \ \ \ \ \ \ \ \ (only (srfi srfi-1) delete-duplicates))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|SRFI-1>

  SRFI-1中有一部分函数已经在R7RS的<scm|(scheme base)>库里面了。本节包含了R7RS定义的<scm|(scheme base)>里面和列表相关的函数，这些函数的实现和测试均在<shell|base.scm>和<shell|base-test.scm>中维护。用户可以通过<scm|(import (liii base))>导入这些函数，或者使用<scm|(import (liii list))>导入这些函数。

  <subsection|构造器>

  <label|r7rs><paragraph|cons><index|cons>

  S7 Scheme内置的R7RS中定义的函数。

  <paragraph|list><index|list>

  S7 Scheme内置的R7RS中定义的函数。

  <paragraph|make-list><index|make-list><scm|(make-list k [fill]) =\<gtr\> list>

  S7 Scheme内置的R7RS中定义的函数。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (make-list 3 #\\a) =\<gtr\> (list #\\a #\\a #\\a))

    (check (make-list 3) =\<gtr\> (list #f #f #f))

    \;

    (check (make-list 0) =\<gtr\> (list ))

    \;
  </scm-chunk>

  <paragraph|circular-list><index|circular-list>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    ; 0 clause BSD, from S7 repo stuff.scm

    (define circular-list

    \ \ (lambda objs

    \ \ \ \ (let ((lst (copy objs)))

    \ \ \ \ \ \ (set-cdr! (list-tail lst (- (length lst) 1)) lst))))

    \;
  </scm-chunk>

  <paragraph|iota><index|iota>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    ; 0 clause BSD, from S7 repo stuff.scm

    (define* (iota n (start 0) (incr 1))

    \ \ (when (not (integer? n))

    \ \ \ \ (type-error "iota: n must be a integer"))

    \ \ (when (\<less\> n 0)

    \ \ \ \ (value-error "iota: n must be postive but received ~d" n))

    \ \ (let ((lst (make-list n)))

    \ \ \ \ (do ((p lst (cdr p))

    \ \ \ \ \ \ \ \ \ (i start (+ i incr)))

    \ \ \ \ \ \ ((null? p) lst)

    \ \ \ \ \ \ (set! (car p) i))))

    \;
  </scm-chunk>

  测试用例

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (iota 3) =\<gtr\> (list 0 1 2))

    (check (iota 3 7) =\<gtr\> (list 7 8 9))

    (check (iota 2 7 2) =\<gtr\> (list 7 9))

    \;

    (check-catch 'value-error (iota -1))

    (check-catch 'type-error (iota 'a))

    \;
  </scm-chunk>

  <subsection|谓词>

  <paragraph|pair?><index|pair?><scm|(obj) =\<gtr\> bool>

  <scm|pair?>是S7 Scheme内置的R7RS定义的函数：当且仅当obj是序对时，返回真。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (pair? '(a . b)) =\<gtr\> #t)

    (check (pair? '(a b c)) =\<gtr\> #t)

    (check (pair? '()) =\<gtr\> #f)

    (check (pair? '#(a b)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|null?><index|null?><scm|(obj) =\<gtr\> bool>

  <scm|null?>是S7 Scheme内置的R7RS定义的函数：当且仅当obj是空列表的时候，返回值为真。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (null? '()) =\<gtr\> #t)

    (check (null? '(1)) =\<gtr\> #f)

    (check (null? '(1 2)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|circular-list?><index|circular-list?>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    ; 0 clause BSD, from S7 repo stuff.scm

    (define circular-list?

    \ \ (lambda (obj)

    \ \ \ \ (catch #t

    \ \ \ \ \ \ (lambda () (infinite? (length obj)))

    \ \ \ \ \ \ (lambda args #f))))

    \;
  </scm-chunk>

  <todo|在Windows上CI的结果是#f，需要修复这个问题>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    ; (check (circular-list? (circular-list 1 2)) =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|null-list?><index|null-list?>

  <scm|null-list?>是一个函数，返回<scm|#t>当且仅当参数是空列表。当参数为空列表，返回<scm|#t>；否则报错。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (null-list? l)

    \ \ (cond ((pair? l) #f)

    \ \ \ \ \ \ \ \ ((null? l) #t)

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (error 'wrong-type-arg "null-list?: argument out of domain" l))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (null-list? '()) =\<gtr\> #t)

    \;
  </scm-chunk>

  当参数为序对，返回<scm|#f>。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (null-list? '(1 . 2)) =\<gtr\> #f)

    \;
  </scm-chunk>

  当参数为非空列表，返回<scm|#f>。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (null-list? '(1 2)) =\<gtr\> #f)

    \;
  </scm-chunk>

  当参数既不是序对也不是列表，报错。

  辨析：<scm|null?>在参数为非序对时，不报错，只是返回<scm|#f>。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (null? 1) =\<gtr\> #f)

    \;
  </scm-chunk>

  如果已经确定需要判别的对象是列表，使用<scm|null-list?>更加合适。<scm|null?>无法分辨非空的序对和非空的列表，命名上偏模糊，不推荐使用。

  <subsection|选择器>

  <paragraph|car><index|car>

  <scm|car>是S7 Scheme内置的R7RS定义的函数，用于返回序对的<scm|\<less\>car\<gtr\>>部分<\footnote>
    一个序对由<scm|\<less\>car\<gtr\>>部分与<scm|\<less\>cdr\<gtr\>>部分组成，形如：<scm|(\<less\>car\<gtr\> . \<less\>cdr\<gtr\>)>
  </footnote>。<scm|car>的参数必须是序对，否则报错；特别地，空列表不是序对，报错。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (car '(a b c . d)) =\<gtr\> 'a)

    \;

    (check (car '(a b c)) =\<gtr\> 'a)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (car '()))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <paragraph|cdr><index|cdr>

  <scm|cdr>是S7 Scheme内置的R7RS定义的函数，用于返回序对的<scm|\<less\>cdr\<gtr\>>部分。<scm|cdr>的参数必须是序对，否则报错；特别地，空列表不是序对，报错。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (cdr '(a b c . d)) =\<gtr\> '(b c . d))

    \;

    (check (cdr '(a b c)) =\<gtr\> '(b c))

    \ \ 

    (check-catch 'wrong-type-arg (cdr '()))

    \;
  </scm-chunk>

  <paragraph|caar><index|caar><scm|(caar pair) =\<gtr\> obj>

  <scm|caar>是S7 Scheme内置的R7RS定义的函数，用于返回序对<scm|\<less\>car\<gtr\>>部分的<scm|\<less\>car\<gtr\>>部分。参数必须是序对，且该序对的<scm|\<less\>car\<gtr\>>部分的内容也要是序对，否则报错。特别地，空列表不是序对，报错。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (caar '((a . b) . c)) =\<gtr\> 'a)

    \;

    (check-catch 'wrong-type-arg (caar '(a b . c)))

    \;

    (check-catch 'wrong-type-arg (caar '()))

    \;
  </scm-chunk>

  <paragraph|list-ref><index|list-ref>

  <scm|list-ref>是S7 Scheme内置的R7RS定义的函数，接收一个列表和一个称为索引值的非负整数k为参数，通过索引值k返回列表的第k个元素（从0开始计数）。当参数为空列表时，报错。当k为负数，报错。当k大于等于列表中元素数时，报错。

  注意<scm|(cons '(1 2) '(3 4))>其实是一个列表，但这个列表的元素不都是整数。这个例子容易理解成结果是一个序对且不是列表。

  <\session|goldfish|default>
    <\folded-io>
      \<gtr\>\ 
    <|folded-io>
      (cons '(1 2) '(3 4))
    <|folded-io>
      ((1 2) 3 4)
    </folded-io>

    <\input>
      \<gtr\>\ 
    <|input>
      \;
    </input>
  </session>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (list-ref (cons '(1 2) '(3 4)) 1) =\<gtr\> 3)

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (list-ref '(a b c) 2) =\<gtr\> 'c)

    \;

    (check-catch 'wrong-type-arg (list-ref '() 0))

    \;

    (check-catch 'out-of-range (list-ref '(a b c) -1))

    (check-catch 'out-of-range (list-ref '(a b c) 3))

    \;
  </scm-chunk>

  <paragraph|first><index|first>

  <scm|first>是一个函数，<scm|car>的同义词，用于返回列表的第1个元素。当列表元素不足1个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (first '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 1)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (first '()))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define first car)

    \;
  </scm-chunk>

  <paragraph|second><index|second>

  <scm|second>是一个函数，<scm|cadr>的同义词，用于返回列表的第2个元素。当列表元素不足2个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (second '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 2)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (second '(1)))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define second cadr)

    \;
  </scm-chunk>

  <paragraph|third><index|third>

  <scm|third>是一个函数，<scm|caddr>的同义词，用于返回列表的第3个元素。当列表元素不足3个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (third '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 3)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (third '(1 2)))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define third caddr)

    \;
  </scm-chunk>

  <paragraph|fourth><index|fourth>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (fourth x) (list-ref x 3))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fourth '(1 2 3 4 5 6)) =\<gtr\> 4)

    \;
  </scm-chunk>

  <paragraph|fifth><index|fifth>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (fifth x) (list-ref x 4))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fifth '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 5)

    \;
  </scm-chunk>

  <paragraph|sixth><index|sixth>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (sixth x) (list-ref x 5))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (sixth '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 6)

    \;
  </scm-chunk>

  <paragraph|seventh><index|seventh>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (seventh x) (list-ref x 6))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (seventh '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 7)

    \;
  </scm-chunk>

  <paragraph|eighth><index|eighth>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (eighth x) (list-ref x 7))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (eighth '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 8)

    \;
  </scm-chunk>

  <paragraph|ninth><index|ninth>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (ninth x) (list-ref x 8))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (ninth '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 9)

    \;
  </scm-chunk>

  <paragraph|tenth><index|tenth>

  <scm|tenth>是一个函数，用于返回列表的第10个元素。当列表元素不足10个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (tenth '(1 2 3 4 5 6 7 8 9 10)) =\<gtr\> 10)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (tenth x)\ 

    \ \ (cadr (cddddr (cddddr x))))

    \;
  </scm-chunk>

  <paragraph|take><index|take>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (take '(1 2 3 4) 3) =\<gtr\> '(1 2 3))

    \;

    (check (take '(1 2 3 4) 4) =\<gtr\> '(1 2 3 4))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (take '(1 2 3 4) 5))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;

    (check (take '(1 2 3 . 4) 3) =\<gtr\> '(1 2 3))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (take '(1 2 3 . 4) 4))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <scm|take>是一个函数，接收一个列表和一个非负整数k为参数，返回列表的前k个元素组成的新列表。当列表元素数量不足k个，报错。

  <\session|goldfish|default>
    <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
      (define (take l k)

      \ \ (let recur ((l l) (k k))

      \ \ \ \ (if (zero? k) '()

      \ \ \ \ \ \ \ \ (cons (car l)

      \ \ \ \ \ \ \ \ \ \ \ \ \ \ (recur (cdr l) (- k 1))))))

      \;
    </scm-chunk>
  </session>

  <paragraph|drop><index|drop>

  <scm|drop>是一个函数，接收一个列表和一个非负整数k为参数，返回去掉列表前k个元素组成的新列表。当列表元素数量不足k个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (drop '(1 2 3 4) 2) =\<gtr\> '(3 4))

    \;

    (check (drop '(1 2 3 4) 4) =\<gtr\> '())

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (drop '(1 2 3 4) 5))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;

    (check (drop '(1 2 3 . 4) 3) =\<gtr\> 4)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (drop '(1 2 3 . 4) 4))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <\session|goldfish|default>
    \;

    <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
      (define (drop l k)

      \ \ (let iter ((l l) (k k))

      \ \ \ \ (if (zero? k) l (iter (cdr l) (- k 1)))))

      \;
    </scm-chunk>
  </session>

  <paragraph|take-right><index|take-right>

  <scm|take-right>是一个函数，接收一个列表和一个非负整数k为参数，取出列表的后k个元素组成新列表，返回这个新列表。当列表元素数量不足k个，报错。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (take-right '(1 2 3 4) 3) =\<gtr\> '(2 3 4))

    \;

    (check (take-right '(1 2 3 4) 4) =\<gtr\> '(1 2 3 4))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (take-right '(1 2 3 4) 5))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;

    (check (take-right '(1 2 3 . 4) 3) =\<gtr\> '(1 2 3 . 4))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (take-right '(1 2 3 . 4) 4))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (take-right l k)

    \ \ (let lp ((lag l) \ (lead (drop l k)))

    \ \ \ \ (if (pair? lead)

    \ \ \ \ \ \ \ \ (lp (cdr lag) (cdr lead))

    \ \ \ \ \ \ \ \ lag)))

    \;
  </scm-chunk>

  <paragraph|drop-right><index|drop-right>

  <scm|drop-right>是一个函数，接收一个列表和一个非负整数k为参数，去掉列表的后k个元素组成新列表，返回这个新列表。当列表元素数量不足k个，报错。当k为负数，报错。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (drop-right l k)

    \ \ (let recur ((lag l) (lead (drop l k)))

    \ \ \ \ (if (pair? lead)

    \ \ \ \ \ \ \ \ (cons (car lag) (recur (cdr lag) (cdr lead)))

    \ \ \ \ \ \ \ \ '())))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (drop-right '(1 2 3 4) 2) =\<gtr\> '(1 2))

    \;

    (check (drop-right '(1 2 3 4) 4) =\<gtr\> '())

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (drop-right '(1 2 3 4) 5))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (drop-right '(1 2 3 4) -1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;

    (check (drop-right '(1 2 3 . 4) 3) =\<gtr\> '())

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (drop-right '(1 2 3 . 4) 4))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|last-pair><index|last-pair>

  <scm|last-pair>是一个函数，以序对形式返回列表的最后一个元素，参数必须是序对，空列表报错。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (last-pair l)

    \ \ (if (pair? (cdr l))

    \ \ \ \ \ \ (last-pair (cdr l)) l))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (last-pair '(a b c)) =\<gtr\> '(c))

    (check (last-pair '(c)) =\<gtr\> '(c))

    \;

    (check (last-pair '(a b . c)) =\<gtr\> '(b . c))

    (check (last-pair '(b . c)) =\<gtr\> '(b . c))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (last-pair '()))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|last><index|last>

  <scm|last>是一个函数，以符号形式返回列表的最后一个元素，参数必须是序对，空列表报错。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (last l)

    \ \ (car (last-pair l)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (last '(a b c)) =\<gtr\> 'c)

    (check (last '(c)) =\<gtr\> 'c)

    \;

    (check (last '(a b . c)) =\<gtr\> 'b)

    (check (last '(b . c)) =\<gtr\> 'b)

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (last '()))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <subsection|常用函数>

  <paragraph|length><index|length><scm|(l) -\<gtr\> integer>

  <scm|length>是一个S7内置的R7RS定义的函数，它接收一个列表为参数，返回该列表中元素的数量。如果参数不是列表，返回0。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (length ()) =\<gtr\> 0)

    (check (length '(a b c)) =\<gtr\> 3)

    (check (length '(a (b) (c d e))) =\<gtr\> 3)

    \;

    (check (length 2) =\<gtr\> #f)

    (check (length '(a . b)) =\<gtr\> -1)

    \;
  </scm-chunk>

  <paragraph|append><index|append>

  <scm|append>是一个S7内置的R7RS定义的函数，它接收多个列表为参数，按顺序拼接在一起，返回一个新的列表。<scm|append>没有参数时，返回空列表。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (append '(a) '(b c d)) =\<gtr\> '(a b c d))

    (check (append '(a b) 'c) =\<gtr\> '(a b . c))

    \;

    (check (append () 'c) =\<gtr\> 'c)

    (check (append) =\<gtr\> '())

    \;
  </scm-chunk>

  <paragraph|count><index|count>

  <scm|count>是一个高阶函数，它接收两个参数：一个谓词和一个列表；返回满足谓词条件的元素在列表中出现的次数。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (count pred list1 . lists)

    \ \ (let lp ((lis list1) (i 0))

    \ \ \ \ (if (null-list? lis) i

    \ \ \ \ \ \ \ \ (lp (cdr lis) (if (pred (car lis)) (+ i 1) i)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (count even? '(3 1 4 1 5 9 2 5 6)) =\<gtr\> 3)

    \;
  </scm-chunk>

  <subsection|折叠和映射>

  <label|r7rs><paragraph|map><index|map>

  <scm|map>是S7的内置高阶函数，它接收一个函数和一个列表为从参数，把该函数应用于该列表的每个元素上，并返回一个新列表。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (map square (list 1 2 3 4 5)) =\<gtr\> '(1 4 9 16 25))

    \;
  </scm-chunk>

  \;

  <label|r7rs><paragraph|for-each><index|for-each><scm|(for-each proc list1 [list2 ...])>

  <scm|for-each>是S7内置的高阶函数。<scm|for-each>的参数与<scm|map>的参数类似，但<scm|for-each>调用<scm|proc>是为了它的副作用，而不是为了它的返回值。与<scm|map>不同，<scm|for-each>保证会按照从第一个元素到最后一个元素的顺序调用<scm|proc>，并且<scm|for-each>返回的值是未指定的。如果给出了多个列表，并且不是所有列表的长度都相同，<scm|for-each>会在最短的列表用尽时终止。当<scm|proc>不接受与<scm|lists>数量相同的参数，报错。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check

    \ \ (let ((v (make-vector 5)))

    \ \ \ \ (for-each (lambda (i) (vector-set! v i (* i i)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (iota 5))

    \ \ \ \ v)

    \ \ =\<gtr\> #(0 1 4 9 16))

    \;

    (check

    \ \ (let ((v (make-vector 5 #f)))

    \ \ \ \ (for-each (lambda (i) (vector-set! v i (* i i)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (iota 4))

    \ \ \ \ v)

    \ \ =\<gtr\> #(0 1 4 9 #f))

    \;

    (check

    \ \ (let ((v (make-vector 5 #f)))

    \ \ \ \ (for-each (lambda (i) (vector-set! v i (* i i)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (iota 0))

    \ \ \ \ v)

    \ \ =\<gtr\> #(#f #f #f #f #f))

    \;
  </scm-chunk>

  \;

  <paragraph|fold><index|fold>

  <scm|fold>是一个高阶函数，它接受三个参数：一个函数、一个初始值和一个列表，将函数累积地应用到一个列表的所有元素上，从左到右，从而将列表折叠成一个单一的值。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (fold f initial l)

    \ \ (when (not (procedure? f))

    \ \ \ \ (error 'type-error "The first param must be a procedure"))

    \ \ (if (null? l)

    \ \ \ \ \ \ initial

    \ \ \ \ \ \ (fold f

    \ \ \ \ \ \ \ \ \ \ \ \ (f (car l) initial)

    \ \ \ \ \ \ \ \ \ \ \ \ (cdr l))))

    \;
  </scm-chunk>

  这是SRFI-1官方提供的实现，我们暂时不用。

  <\scm-code>
    (define (fold kons knil lis1 . lists)

    \ \ (if (pair? lists)

    \ \ \ \ \ \ (let lp ((lists (cons lis1 lists)) (ans knil))

    \ \ \ \ \ \ \ \ (receive (cars+ans cdrs) (%cars+cdrs+ lists ans)

    \ \ \ \ \ \ \ \ \ \ (if (null? cars+ans) ans

    \ \ \ \ \ \ \ \ \ \ \ \ \ (lp cdrs (apply kons cars+ans)))))

    \;

    \ \ \ \ \ \ (let lp ((lis lis1) (ans knil))

    \ \ \ \ \ \ \ \ (if (null-list? lis) ans

    \ \ \ \ \ \ \ \ \ \ \ \ (lp (cdr lis) (kons (car lis) ans))))))
  </scm-code>

  常见的用法：

  从初始值开始，依次累加列表中的元素，返回一个数；当列表为空列表时，返回初始值。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fold + 0 '(1 2 3 4)) =\<gtr\> 10)

    \;

    (check (fold + 0 '()) =\<gtr\> 0)

    \;

    (check-catch 'type-error (fold 0 + '(1 2 3 4)))

    \;
  </scm-chunk>

  反转列表中的元素，返回一个新列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fold cons () '(1 2 3 4)) =\<gtr\> '(4 3 2 1))

    \;
  </scm-chunk>

  统计列表中满足谓词的元素数量，返回这个数量。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (fold (lambda (x count) (if (symbol? x) (+ count 1) count))

    \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ '(a b 1 2 3 4))

    \ \ =\<gtr\> 2)

    \;
  </scm-chunk>

  <paragraph|fold-right><index|fold-right>

  <scm|fold-right>与<scm|fold>类似，不同的是，<scm|fold-right>是从右到左折叠。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (fold-right f initial l)

    \ \ (if (null? l)

    \ \ \ \ initial

    \ \ \ \ (f (car l)

    \ \ \ \ \ \ \ \ (fold-right f

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ initial

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cdr l)))))

    \;
  </scm-chunk>

  这是SRFI-1官方提供的实现，我们暂时不用：

  <\scm-code>
    (define (fold-right kons knil lis1 . lists)

    \ \ (if (pair? lists)

    \ \ \ \ \ \ (let recur ((lists (cons lis1 lists)))

    \ \ \ \ \ \ \ \ (let ((cdrs (%cdrs lists)))

    \ \ \ \ \ \ \ \ \ \ (if (null? cdrs) knil

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (apply kons (%cars+ lists (recur cdrs))))))

    \;

    \ \ \ \ \ \ (let recur ((lis lis1))

    \ \ \ \ \ \ \ \ (if (null-list? lis) knil

    \ \ \ \ \ \ \ \ \ \ \ \ (let ((head (car lis)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (kons head (recur (cdr lis))))))))
  </scm-code>

  在用作累加、统计时，<scm|fold-right>与<scm|fold>的结果是相同的。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fold-right + 0 '(1 2 3 4)) =\<gtr\> 10)

    \;

    (check (fold-right + 0 '()) =\<gtr\> 0)

    \;

    (check

    \ \ (fold-right (lambda (x count) (if (symbol? x) (+ count 1) count))

    \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ '(a b 1 2 3 4))

    \ \ =\<gtr\>

    \ \ 2)

    \;
  </scm-chunk>

  但<scm|fold-right>与<scm|fold>的折叠方向是相反的，这就使得列表原本的顺序得以保持，不会反转。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (fold-right cons () '(1 2 3 4)) =\<gtr\> '(1 2 3 4))

    \;
  </scm-chunk>

  <paragraph|reduce><index|reduce>

  <scm|reduce>与<scm|fold>类似，但有微妙且关键的不同。只有在列表为空列表时，才会使用这个初始值。在列表不是空列表时，则把列表的<scm|\<less\>car\<gtr\>>部分取出作为<scm|fold>的初始值，又把列表的<scm|\<less\>cdr\<gtr\>>部分取出作为<scm|fold>的列表。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (reduce f initial l)

    \ \ (if (null-list? l) initial

    \ \ \ \ \ \ (fold f (car l) (cdr l))))

    \;
  </scm-chunk>

  在用作累加时，<scm|reduce>与<scm|fold>的结果是相同的。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (reduce + 0 '(1 2 3 4)) =\<gtr\> 10)

    \;

    (check (reduce + 0 '()) =\<gtr\> 0)

    \;
  </scm-chunk>

  不适用于反转列表中的元素，但当列表非空，返回的不再是列表，而是序对。因为<scm|reduce>会把非空列表的第一个元素取出来作为<scm|fold>的初始值。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (reduce cons () '(1 2 3 4)) =\<gtr\> '(4 3 2 . 1))

    \;
  </scm-chunk>

  不适用于统计列表中满足谓词的元素数量，因为<scm|reduce>会把非空列表的第一个元素取出来作为<scm|fold>的初始值，引发错误。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda

    \ \ \ \ \ \ ()

    \ \ \ \ \ \ (reduce (lambda (x count) (if (symbol? x) (+ count 1) count))

    \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ '(a b 1 2 3 4)))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <paragraph|reduce-right><index|reduce-right>

  <scm|reduce-right>与<scm|reduce>类似，不同的是，<scm|reduce-right>是从右到左规约。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (reduce-right f initial l)

    \ \ (if (null-list? l) initial

    \ \ \ \ \ \ (let recur ((head (car l)) (l (cdr l)))

    \ \ \ \ \ \ \ \ (if (pair? l)

    \ \ \ \ \ \ \ \ \ \ \ \ (f head (recur (car l) (cdr l)))

    \ \ \ \ \ \ \ \ \ \ \ \ head))))

    \;
  </scm-chunk>

  在用作累加时，<scm|reduce-right>与<scm|fold>的结果是相同的。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (reduce-right + 0 '(1 2 3 4)) =\<gtr\> 10)

    \;

    (check (reduce-right + 0 '()) =\<gtr\> 0)

    \;
  </scm-chunk>

  也不适用于重列列表中的元素，以及统计列表中满足谓词的元素数量。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (reduce-right cons () '(1 2 3 4))

    \ \ \ \ \ \ \ =\<gtr\> '(1 2 3 . 4) )

    \;

    (check

    \ \ (reduce-right (lambda (x count) (if (symbol? x) (+ count 1) count))

    \ \ \ \ \ \ \ \ 0

    \ \ \ \ \ \ \ \ '(a b 1 2 3 4))

    \ \ =\<gtr\> 6)

    \;
  </scm-chunk>

  <subsection|过滤和分组>

  <paragraph|filter><index|filter>

  <scm|filter>是一个高阶函数，接收一个谓词和一个列表为参数，从这个列表中筛出满足谓词的元素，组成一个新列表，返回这个新列表。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (filter pred l)

    \ \ (let recur ((l l))

    \ \ \ \ (if (null-list? l) l

    \ \ \ \ \ \ \ \ (let ((head (car l))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (tail (cdr l)))

    \ \ \ \ \ \ \ \ \ \ (if (pred head)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (let ((new-tail (recur tail)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (eq? tail new-tail) l

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons head new-tail)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (recur tail))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (filter even? '(-2 -1 0 1 2)) =\<gtr\> '(-2 0 2))

    \;
  </scm-chunk>

  <paragraph|partition><index|partition>

  <scm|partition>是一个高阶函数，接收一个谓词和一个列表为参数，从这个列表中分别筛出满足和不满足谓词的元素，各组成一个新列表，返回以这两个新列表组成的序对。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (partition pred l)

    \ \ (let loop ((lst l) (satisfies '()) (dissatisfies '()))

    \ \ \ \ (cond ((null? lst)

    \ \ \ \ \ \ \ \ \ \ \ (cons satisfies dissatisfies))

    \ \ \ \ \ \ \ \ \ \ ((pred (car lst))

    \ \ \ \ \ \ \ \ \ \ \ (loop (cdr lst) (cons (car lst) satisfies) dissatisfies))

    \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ (loop (cdr lst) satisfies (cons (car lst) dissatisfies))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (partition symbol? '(one 2 3 four five 6))

    \ \ =\<gtr\> (cons '(five four one) '(6 3 2)))

    \;
  </scm-chunk>

  <paragraph|remove><index|remove>

  <scm|remove>是一个高阶函数，接收一个谓词和一个列表为参数，从这个列表中去掉满足谓词的元素，组成一个新列表，返回这个新列表。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (remove pred l)

    \ \ (filter (lambda (x) (not (pred x))) l))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (remove even? '(-2 -1 0 1 2)) =\<gtr\> '(-1 1))

    \;
  </scm-chunk>

  <subsection|搜索>

  <paragraph|memq><index|memq>

  <scm|memq>是一个S7内置函数，和<scm|member>类似，但判断元素等价的谓词是<scm|eq?>。也就是说，检查的是两个元素在是否是同一个实例，即它们是否具有相同的内存地址。

  对比使用<scm|equal?>的<scm|member>或使用<scm|<scm|eqv?>>的<scm|memv>，这种检查最为“严格”，适用于判断的元素类型最少，速度最快，适用于判断布尔值（<scm|#t>、<scm|#f>）、符号、整数（浮点数和复数不行）、函数（的值）这些类型的元素是否在列表中。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (memq #f '(1 #f 2 3)) =\<gtr\> '(#f 2 3))

    (check (memq 'a '(1 a 2 3)) =\<gtr\> '(a 2 3))

    (check (memq 2 '(1 2 3)) =\<gtr\> '(2 3))

    \;

    (check (memq 2.0 '(1 2.0 3)) =\<gtr\> #f)

    (check (memq 2+0i '(1 2+0i 3)) =\<gtr\> #f)

    \;

    (define num1 3)

    (define num2 3)

    (check (memq num1 '(3 num2)) =\<gtr\> '(3 num2))

    (check (memq 3 '(num1 num2)) =\<gtr\> #f)

    (check (memq 'num1 '(num1 num2)) =\<gtr\> '(num1 num2))

    \;

    (check (memq (+ 1 1) '(1 2 3)) =\<gtr\> '(2 3))

    \;
  </scm-chunk>

  <paragraph|memv><index|memv>

  <scm|memv>是一个S7内置函数，和<scm|member>类似，但判断元素元素的谓词是<scm|eqv?>。也就是说，检查的是两个元素是否相同或在数值上等价。

  比使用<scm|equal?>的<scm|member>“严格”，但比使用<scm|<scm|eq?>>的<scm|memq>“宽松”，适用于判断的元素类型次全（<scm|memv>能实现的功能<scm|member>都能实现），速度中等，适用于判断数值类元素（整数、浮点数、复数）是否在列表中。但是注意，即使数值相同也不视为同一元素。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (memv 2 '(1 2 3)) =\<gtr\> '(2 3))

    (check (memv 2.0 '(1 2.0 3)) =\<gtr\> '(2.0 3))

    (check (memv 2+0i '(1 2+0i 3)) =\<gtr\> '(2+0i 3))

    \;

    (check (memv 2 '(1 2.0 3)) =\<gtr\> #f)

    (check (memv 2 '(1 2+0i 3)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|member><index|member>

  <scm|member>是一个S7内置函数，接收一个元素和一个列表为参数，返回包含该元素的第一个子列表。当元素不在列表中，返回<scm|#f>。当列表为空列表，返回<scm|#f>。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (member 2 '(1 2 3)) =\<gtr\> '(2 3))

    (check (member 0 '(1 2 3)) =\<gtr\> #f)

    (check (member 0 '()) =\<gtr\> #f)

    \ 
  </scm-chunk>

  注意，判断两个元素等价的谓词是<scm|equal?>。也就是说，检查的是两个元素在结构和内容上是否等价。

  对比使用<scm|eq?>的<scm|memq>或使用<scm|<scm|eqv?>>的<scm|memv>，这种检查最为“宽松”，适用判断的元素类型最全，但速度最慢（因为它会递归地比较复合数据结构的每个部分），建议用于判断字符串、序对、列表这些类型的元素是否在列表中，如果无需判断这些类型，建议选用<scm|memv>或<scm|memq>。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (member "1" '(0 "1" 2 3)) =\<gtr\> '("1" 2 3))

    (check (member '(1 . 2) '(0 (1 . 2) 3)) =\<gtr\> '((1 . 2) 3))

    (check (member '(1 2) '(0 (1 2) 3)) =\<gtr\> '((1 2) 3))

    \;
  </scm-chunk>

  <paragraph|find><index|find>

  <scm|find>是一个高阶函数，接收一个谓词和一个列表为参数，返回该列表中第一个满足谓词的元素。当列表为空列表，或列表中没有满足谓词的元素，返回<scm|#f>。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (find pred l)

    \ \ (cond ((null? l) #f)

    \ \ \ \ \ \ \ \ ((pred (car l)) (car l))\ 

    \ \ \ \ \ \ \ \ (else (find pred (cdr l)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (find even? '(3 1 4 1 5 9)) =\<gtr\> 4)

    \;

    (check (find even? '()) =\<gtr\> #f)

    \;

    (check (find even? '(1 3 5 7 9)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|take-while><index|take-while>

  <scm|take-while>是一个高阶函数，接收一个谓词和一个列表为参数，按列表顺序筛出满足谓词的元素，直到不满足谓词的那个一个就停止筛选，返回筛出的元素组成的列表。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (take-while pred lst)

    \ \ (if (null? lst)\ 

    \ \ \ \ \ \ '()

    \ \ \ \ \ \ (if (pred (car lst))

    \ \ \ \ \ \ \ \ \ \ (cons (car lst) (take-while pred (cdr lst)))

    \ \ \ \ \ \ \ \ \ \ '())))

    \;
  </scm-chunk>

  当参数的列表为空列表，无论谓词是什么都返回空列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check <code*|(take-while even? '())> =\<gtr\> '())

    \;
  </scm-chunk>

  当列表中所有元素都满足谓词，返回原列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (take-while (lambda (x) #t) '(1 2 3))

    \ \ =\<gtr\> '(1 2 3))

    \;
  </scm-chunk>

  当列表中没有元素满足谓词，返回空列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (take-while (lambda (x) #f) '(1 2 3))

    \ \ =\<gtr\> '())

    \;
  </scm-chunk>

  当列表的第一个元素就不满足谓词，返回空列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (take-while (lambda (x) (not (= x 1))) '(1 2 3))

    \ \ =\<gtr\> '())

    \;
  </scm-chunk>

  筛出元素的过程按照列表的顺序进行，当一个元素已经不满足谓词，那么这个元素之后的元素不会被筛出。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (take-while (lambda (x) (\<less\> x 3)) '(1 2 3 0))

    \ \ =\<gtr\> '(1 2))

    \;
  </scm-chunk>

  <paragraph|drop-while><index|drop-while>

  <scm|drop-while>是一个高阶函数，接收一个谓词和一个列表为参数，按列表顺序丢掉满足谓词的元素，直到不满足谓词的那个一个就停止丢掉，返回剩下的元素组成的列表。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (drop-while pred l)

    \ \ (if (null? l)

    \ \ \ \ \ \ '()

    \ \ \ \ \ \ (if (pred (car l))

    \ \ \ \ \ \ \ \ \ \ (drop-while pred (cdr l))

    \ \ \ \ \ \ \ \ \ \ l)))

    \;
  </scm-chunk>

  当列表为空列表，返回空列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (drop-while even? '()) =\<gtr\> '())

    \;
  </scm-chunk>

  当列表中所有元素都满足谓词，返回空列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (drop-while (lambda (x) #t) '(1 2 3)) =\<gtr\> '())

    \;
  </scm-chunk>

  当列表中没有元素满足谓词，返回原列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (drop-while (lambda (x) #f) '(1 2 3)) =\<gtr\> '(1 2 3))

    \;
  </scm-chunk>

  当列表的第一个元素就不满足谓词，返回原列表。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (drop-while (lambda (x) (not (= x 1))) '(1 2 3))

    \ \ =\<gtr\> '(1 2 3))

    \;
  </scm-chunk>

  <paragraph|list-index><index|list-index>

  <scm|list-index>是一个高阶函数，接收一个谓词和一个列表为参数，返回第一个符合谓词要求的元素的位置索引。当列表为空列表，或列表中没有满足谓词的元素，返回<scm|#f>。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (list-index pred l)

    \ \ \ \ (let loop ((index 0) (l l))

    \ \ \ \ \ \ (if (null? l)

    \ \ \ \ \ \ \ \ \ \ #f

    \ \ \ \ \ \ \ \ \ \ (if (pred (car l))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ index

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ index 1) (cdr l))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (list-index even? '(3 1 4 1 5 9)) =\<gtr\> 2)

    (check (list-index even? '()) =\<gtr\> #f)

    (check (list-index even? '(1 3 5 7 9)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|any><index|any>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (any pred? l)

    \ \ (cond ((null? l) #f)

    \ \ \ \ \ \ \ \ ((pred? (car l)) #t)

    \ \ \ \ \ \ \ \ (else (any pred? (cdr l)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (any integer? '()) =\<gtr\> #f)

    (check (any integer? '(a 3.14 "3")) =\<gtr\> #f)

    (check (any integer? '(a 3.14 3)) =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|every><index|every>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (every pred? l)

    \ \ (cond ((null? l) #t)

    \ \ \ \ \ \ \ \ ((not (pred? (car l))) #f)

    \ \ \ \ \ \ \ \ (else (every pred? (cdr l)))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (every integer? '()) =\<gtr\> #t)

    (check (every integer? '(a 3.14 3)) =\<gtr\> #f)

    (check (every integer? '(1 2 3)) =\<gtr\> #t)

    \;
  </scm-chunk>

  <subsection|删除>

  公共子函数，用于处理可选的<scm|maybe-equal>参数。

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (%extract-maybe-equal maybe-equal)

    \ \ (let ((my-equal (if (null-list? maybe-equal)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car maybe-equal))))

    \ \ \ \ (if (procedure? my-equal)

    \ \ \ \ \ \ \ \ my-equal

    \ \ \ \ \ \ \ \ (error 'wrong-type-arg "maybe-equal must be procedure"))))
  </scm-chunk>

  <paragraph|delete><index|delete>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    (define (delete x l . maybe-equal)

    \ \ (let ((my-equal (%extract-maybe-equal maybe-equal)))

    \ \ \ \ (filter (lambda (y) (not (my-equal x y))) l)))

    \;
  </scm-chunk>

  测试用例

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (delete 1 (list 1 2 3 4)) =\<gtr\> (list 2 3 4))

    \;

    (check (delete 0 (list 1 2 3 4)) =\<gtr\> (list 1 2 3 4))

    \;

    (check (delete #\\a (list #\\a #\\b #\\c) char=?)

    \ \ \ \ \ \ \ =\<gtr\> (list #\\b #\\c))

    \;

    (check (delete #\\a (list #\\a #\\b #\\c) (lambda (x y) #f))

    \ \ \ \ \ \ \ =\<gtr\> (list #\\a #\\b #\\c))

    \;

    (check (delete 1 (list )) =\<gtr\> (list ))

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda ()

    \ \ \ \ \ \ (check (delete 1 (list 1 2 3 4) 'not-pred) =\<gtr\> 1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|delete-duplicates><index|delete-duplicates>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|true>
    ;;; right-duplicate deletion

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;; delete-duplicates delete-duplicates!

    ;;;

    ;;; Beware -- these are N^2 algorithms. To efficiently remove duplicates

    ;;; in long lists, sort the list to bring duplicates together, then use a

    ;;; linear-time algorithm to kill the dups. Or use an algorithm based on

    ;;; element-marking. The former gives you O(n lg n), the latter is linear.

    \;

    (define (delete-duplicates lis . maybe-equal)

    \ \ (let ((my-equal (%extract-maybe-equal maybe-equal)))

    \ \ \ \ (let recur ((lis lis))

    \ \ \ \ \ \ (if (null-list? lis)

    \ \ \ \ \ \ \ \ \ \ lis

    \ \ \ \ \ \ \ \ \ \ (let* ((x (car lis))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (tail (cdr lis))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (new-tail (recur (delete x tail my-equal))))

    \ \ \ \ \ \ \ \ \ \ \ \ (if (eq? tail new-tail)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lis

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cons x new-tail)))))))

    \;
  </scm-chunk>

  测试用例

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (delete-duplicates (list 1 1 2 3)) =\<gtr\> (list 1 2 3))

    (check (delete-duplicates (list 1 2 3)) =\<gtr\> (list 1 2 3))

    (check (delete-duplicates (list 1 1 1)) =\<gtr\> (list 1))

    \;

    (check (delete-duplicates (list )) =\<gtr\> (list ))

    \;

    (check (delete-duplicates (list 1 1 2 3) (lambda (x y) #f))

    \ \ \ \ \ \ \ =\<gtr\> (list 1 1 2 3))

    \;
  </scm-chunk>

  如果判断相等的函数类型不正确，会报错：

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda

    \ \ \ \ \ \ ()

    \ \ \ \ \ \ (check (delete-duplicates (list 1 1 2 3) 'not-pred) =\<gtr\> 1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\> #t)

    \;
  </scm-chunk>

  <section|三鲤扩展库>

  <paragraph|length=?><index|length=?><scm|(x l) =\<gtr\> boolean>

  <\description>
    <item*|x>期望的列表长度，如果长度为负数，该函数会抛出<scm|value-error>

    <item*|l>列表
  </description>

  快速判断一个列表<scm|l>的长度是否为<scm|x>。由于<scm|(= x (length l))>这种判断方式的复杂度是<math|O<around*|(|n|)>>，故而需要<scm|length=?>这种快速的判断方式。

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check-true (length=? 3 (list 1 2 3)))

    (check-false (length=? 2 (list 1 2 3)))

    (check-false (length=? 4 (list 1 2 3)))

    \;

    (check-true (length=? 0 (list )))

    (check-catch 'value-error (length=? -1 (list )))

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (length=? x scheme-list)

    \ \ (when (\<less\> x 0)

    \ \ \ \ (value-error "length=?: expected non-negative integer x but received ~d" x))

    \ \ (cond ((and (= x 0) (null? scheme-list)) #t)

    \ \ \ \ \ \ \ \ ((or (= x 0) (null? scheme-list)) #f)

    \ \ \ \ \ \ \ \ (else (length=? (- x 1) (cdr scheme-list)))))

    \;
  </scm-chunk>

  <paragraph|list-view><index|list-view>

  由于Scheme的List和数据的流向是相反的：

  <\scm-code>
    (map (lambda (x) (* x x))

    \ \ \ \ \ (map (lambda (x) (+ x 1))

    \ \ \ \ \ \ \ \ \ \ (list 1 2 3)))
  </scm-code>

  \;

  所以我们实现了<scm|list-view>，采用和Scala的List类似的语法来处理数据：

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check ((list-view (list 1 2 3))) =\<gtr\> (list 1 2 3))

    \;

    (check (((list-view (list 1 2 3))

    \ \ \ \ \ \ \ \ map (lambda (x) (+ x 1)))) =\<gtr\> (list 2 3 4))

    \;

    (check (((list-view (list 1 2 3))

    \ \ \ \ \ \ \ \ map (lambda (x) (+ x 1))

    \ \ \ \ \ \ \ \ map (lambda (x) (* x x))))

    \ \ \ \ \ \ \ =\<gtr\> (list 4 9 16))

    \;
  </scm-chunk>

  <scm|(list-view 1 2 3)>得到的是函数，需要在外面再加一层括号才能得到<scm|(list 1 2 3)>。

  <\big-figure|<wide-tabular|<tformat|<table|<row|<\cell>
    <\scm-code>
      (map (lambda (x) (* x x))

      \ \ \ \ \ (map (lambda (x) (+ x 1))

      \ \ \ \ \ \ \ \ \ \ (list 1 2 3)))
    </scm-code>
  </cell>|<\cell>
    <\scm-code>
      (((list-view 1 2 3)

      \ \ \ \ \ \ \ \ map (lambda (x) (+ x 1))

      \ \ \ \ \ \ \ \ map (lambda (x) (* x x))))
    </scm-code>
  </cell>>>>>>
    使用list处理数据和使用list-view处理数据的对比
  </big-figure>

  实现list-view时需要考虑三种情况和一种例外情况。

  <\description>
    <item*|无参数>也就是直接在list-view得到的结果外面添加括号，此时得到的是list-view对应的list

    <item*|有两个参数>这里举例说明，<scm|((list-view 1 2 3) map (lambda (x) (+ x 1)))>实际的计算过程是：

    <\enumerate>
      <item>计算并得到结果<scm|(map (lambda (x) (+ x 1)) (list 1 2 3)) =\<gtr\> (list 2 3 4)>

      <item>将计算结果包装到 <scm|list-view> 里面，这里使用了<scm|apply>这个内置函数
    </enumerate>

    其实也是树的转换：

    <\big-figure|<scm|<tree|(list-view 1 2 3)|map|(lambda (x) (+ x 1))>><space|2em><math|\<Rightarrow\>><space|2em><scm|<tree|map|(lambda (x) (+ x 1))|(list 1 2 3)>>>
      原理的可视化
    </big-figure>

    <item*|偶数个参数>在上述两个递归退出条件写好的情况下，在思考这种一般的情况。

    需要计算<scm|((list-view 1 2 3) hf1 f1 hf2 f2 ... hfn fn)>，其中hf指的是high-order function，也就是高阶函数。也就是需要计算：

    <\scm>
      ((((list-view 1 2 3) hf1 f1) hf2 f2) ... hfn fn)
    </scm>

    \;
  </description>

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (list-view scheme-list)

    \ \ (define (f-inner-reducer scheme-list filter filter-func rest-funcs)

    \ \ \ \ (cond ((null? rest-funcs) (list-view (filter filter-func scheme-list)))

    \ \ \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ \ \ (f-inner-reducer (filter filter-func scheme-list)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car rest-funcs)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cadr rest-funcs)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cddr rest-funcs)))))

    \ \ (define (f-inner . funcs)

    \ \ \ \ (cond ((null? funcs) scheme-list)

    \ \ \ \ \ \ \ \ \ \ ((length=? 2 funcs)

    \ \ \ \ \ \ \ \ \ \ \ (list-view ((car funcs) (cadr funcs) scheme-list)))

    \ \ \ \ \ \ \ \ \ \ ((even? (length funcs))

    \ \ \ \ \ \ \ \ \ \ \ (f-inner-reducer scheme-list

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (car funcs)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cadr funcs)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (cddr funcs)))

    \ \ \ \ \ \ \ \ \ \ (else (error 'wrong-number-of-args

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "list-view only accepts even number of args"))))

    \ \ f-inner)

    \;
  </scm-chunk>

  <paragraph|flatmap><index|flatmap>

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (flatmap f seq)

    \ \ (fold-right append () (map f seq)))

    \;
  </scm-chunk>

  \;

  <paragraph|not-null-list?><index|not-null-list?>

  <scm|null-list?>的反面，会抛出异常。

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (not-null-list? l)

    \ \ (cond ((pair? l)

    \ \ \ \ \ \ \ \ \ (or (null? (cdr l)) (pair? (cdr l))))

    \ \ \ \ \ \ \ \ ((null? l) #f)

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (error 'type-error "type mismatch"))))

    \;
  </scm-chunk>

  <paragraph|list-null?><index|null-list?>

  <scm|null-list?>的没有异常的版本，只要不是<scm|list>，都是<scm|#f>。

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (list-null? l)

    \ \ (and (not (pair? l)) (null? l)))

    \;
  </scm-chunk>

  <paragraph|list-not-null?><index|list-not-null?>

  <scm|not-null-list?>的没有异常的版本。

  \;

  <\scm-chunk|goldfish/liii/list.scm|true|true>
    (define (list-not-null? l)

    \ \ (and (pair? l)

    \ \ \ \ \ \ \ (or (null? (cdr l)) (pair? (cdr l)))))

    \;
  </scm-chunk>

  \;

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|true>
    (check (not-null-list? (list 1)) =\<gtr\> #t)

    (check (list-not-null? (list 1)) =\<gtr\> #t)

    (check (list-null? (list 1)) =\<gtr\> #f)

    \;

    (check (not-null-list? (list 1 2 3)) =\<gtr\> #t)

    (check (list-not-null? (list 1 2 3)) =\<gtr\> #t)

    (check (list-null? (list 1 2 3)) =\<gtr\> #f)

    \;

    (check (not-null-list? '(a)) =\<gtr\> #t)

    (check (list-not-null? '(a)) =\<gtr\> #t)

    (check (list-null? '(a)) =\<gtr\> #f)

    \;

    (check (not-null-list? '(a b c)) =\<gtr\> #t)

    (check (list-not-null? '(a b c)) =\<gtr\> #t)

    (check (list-null? '(a b c)) =\<gtr\> #f)

    \;

    (check (not-null-list? ()) =\<gtr\> #f)

    (check (list-not-null? ()) =\<gtr\> #f)

    (check (list-null? ()) =\<gtr\> #t)

    \;

    ; '(a) is a pair and a list

    ; '(a . b) is a pair but not a list

    (check (not-null-list? '(a . b)) =\<gtr\> #f)

    (check (list-not-null? '(a . b)) =\<gtr\> #f)

    (check (list-null? '(a . b)) =\<gtr\> #f)

    \;

    (check-catch 'type-error (not-null-list? 1))

    (check (list-not-null? 1) =\<gtr\> #f)

    (check (list-null? 1) =\<gtr\> #f)

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/list.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-1.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/list-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii vector)><label|chapter:liii_vector>

  <section|许可证>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/vector.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|true|true>
    (define-library (srfi srfi-133)

    \;

    (export

    \ \ vector-empty?

    \ \ vector-count

    \ \ vector-any vector-every vector-copy vector-copy!

    \ \ vector-index vector-index-right vector-partition

    \ \ vector-swap!)

    (import (scheme base))

    (begin

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/vector.scm|true|true>
    (define-library (liii vector)

    \;

    (export

    \ \ ; S7 Scheme built-in

    \ \ make-vector vector vector-length vector-ref vector-set! vector-\<gtr\>list list-\<gtr\>vector

    \ \ ; from (scheme base)

    \ \ vector-copy vector-fill! vector-copy! vector-\<gtr\>string string-\<gtr\>vector

    \ \ vector-map vector-for-each

    \ \ ; from (srfi srfi-133)

    \ \ vector-empty?

    \ \ vector-count

    \ \ vector-any vector-every vector-copy vector-copy!

    \ \ vector-index vector-index-right vector-partition

    \ \ vector-swap!)

    (import (srfi srfi-133)

    \ \ \ \ \ \ \ \ (scheme base))

    (begin

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (import (liii list)

    \ \ \ \ \ \ \ \ (liii check)

    \ \ \ \ \ \ \ \ (liii vector)

    \ \ \ \ \ \ \ \ (only (scheme base) let-values))

    \;

    (check-set-mode! 'report-failed)

    \;

    (for-each (lambda (p) (check (procedure? p) =\<gtr\> #t))

    \ \ (list

    \ \ \ vector-empty?

    \ \ \ vector-count

    \ \ \ vector-any vector-every vector-copy vector-copy!

    \ \ \ vector-index vector-index-right vector-partition

    \ \ \ vector-swap!))

    \;
  </scm-chunk>

  <section|实现>

  <subsection|构造器>

  <label|r7rs><paragraph|make-vector><scm|(k [fill]) =\<gtr\> vector><index|make-vector>

  返回长度为k的向量，如果提供了fill，则采用fill作为每一个元素的初始值，否则每一个元素的初始值是未指定。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (make-vector 1 1) =\<gtr\> (vector 1))

    (check (make-vector 3 'a) =\<gtr\> (vector 'a 'a 'a))

    \;

    (check (make-vector 0) =\<gtr\> (vector ))

    (check (vector-ref (make-vector 1) 0) =\<gtr\> #\<less\>unspecified\<gtr\>)

    \;
  </scm-chunk>

  <label|r7rs><paragraph|vector><scm|(obj1 obj2 ...) =\<gtr\> vector><index|vector>

  返回一个新分配的向量，其元素包含给定的参数。类似于<scm|list>。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (vector 'a 'b 'c) =\<gtr\> #(a b c))

    (check (vector) =\<gtr\> #())

    \;
  </scm-chunk>

  <paragraph|vector-unfold>

  <paragraph|vector-unfold-right>

  <label|r7rs><paragraph|vector-copy><scm|(v [start [end]]) =\<gtr\> vector><index|vector-copy>

  返回一个新的分配副本，包含给定向量从开始到结束的元素。新向量的元素与旧向量的元素相同（在eqv?的意义上）。

  <\scm-code>
    (define (vector-copy v)

    \ \ (let ((new-v (make-vector (vector-length v))))

    \ \ \ \ (let loop ((i 0))

    \ \ \ \ \ \ \ \ \ (if (= i (vector-length v))

    \ \ \ \ \ \ \ \ \ \ \ \ \ new-v

    \ \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! new-v i (vector-ref v i))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1)))))))
  </scm-code>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define* (vector-copy v (start 0) (end (vector-length v)))

    \ \ (if (or (\<gtr\> start end) (\<gtr\> end (vector-length v)))

    \ \ \ \ \ \ (error 'out-of-range "vector-copy")

    \ \ \ \ \ \ (let ((new-v (make-vector (- end start))))

    \ \ \ \ \ \ \ \ (let loop ((i start) (j 0))

    \ \ \ \ \ \ \ \ \ \ (if (\<gtr\>= i end)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ new-v

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! new-v j (vector-ref v i))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) (+ j 1))))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (check (vector-copy #(0 1 2 3)) =\<gtr\> #(0 1 2 3))

    (check (vector-copy #(0 1 2 3) 1) =\<gtr\> #(1 2 3))

    (check (vector-copy #(0 1 2 3) 3) =\<gtr\> #(3))

    (check (vector-copy #(0 1 2 3) 4) =\<gtr\> #())

    \;

    (check-catch 'out-of-range (vector-copy #(0 1 2 3) 5))

    (check-catch 'out-of-range (vector-copy #(0 1 2 3) 1 5))

    \;

    (define my-vector #(0 1 2 3))

    (check (eqv? my-vector (vector-copy #(0 1 2 3))) =\<gtr\> #f)

    (check-true

    \ \ (eqv? (vector-ref my-vector 2)

    \ \ \ \ \ \ \ \ (vector-ref (vector-copy #(0 1 2 3)) 2)))

    \;

    (check (vector-copy #(0 1 2 3) 1 1) =\<gtr\> #())

    (check (vector-copy #(0 1 2 3) 1 2) =\<gtr\> #(1))

    (check (vector-copy #(0 1 2 3) 1 4) =\<gtr\> #(1 2 3))

    \;
  </scm-chunk>

  <paragraph|vector-reverse-copy>

  <label|r7rs><paragraph|vector-append><scm|(v1 v2 v3 ...) =\<gtr\> vector><index|vector-append>

  返回一个新分配的向量，其元素是给定向量的元素的拼接。这是一个S7内置的函数。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (vector-append #(0 1 2) #(3 4 5)) =\<gtr\> #(0 1 2 3 4 5))

    \;
  </scm-chunk>

  <subsection|谓词>

  <paragraph|vector?><index|vector?><scm|(vector? obj) =\<gtr\> bool>

  如果obj是一个向量返回<scm|#t>，否则返回<scm|#f>。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (vector? #(1 2 3)) =\<gtr\> #t)

    (check (vector? #()) =\<gtr\> #t)

    (check (vector? '(1 2 3)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|vector-empty?><index|vector-empty?>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|true|true>
    (define (vector-empty? v)

    \ \ (when (not (vector? v))

    \ \ \ \ (error 'type-error "v is not a vector"))

    \ \ (zero? (vector-length v)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (check-true (vector-empty? (vector)))

    (check-false (vector-empty? (vector 1)))

    (check-catch 'type-error (vector-empty? 1))

    \;
  </scm-chunk>

  <paragraph|vector=>

  <subsection|选择器>

  <label|r7rs><paragraph|vector-length><scm|(v) =\<gtr\> integer><index|vector-length>

  以整数返回向量中元素的数量。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (vector-length #(1 2 3)) =\<gtr\> 3)

    (check (vector-length #()) =\<gtr\> 0)

    \;
  </scm-chunk>

  <label|r7rs><paragraph|vector-ref><scm|(vector-ref v k )><index|vector-ref>

  返回向量中索引为 k 的元素的内容。当 k 不是向量的有效索引，报错。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (vector-ref #(1 2 3) 0) =\<gtr\> 1)

    (check (vector-ref #(1 2 3) 2) =\<gtr\> 3)

    \;

    (check-catch 'out-of-range (vector-ref #(1 2 3) 3))

    (check-catch 'out-of-range (vector-ref #() 0))

    \ \ 

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (vector-ref #(1 2 3) 2.0))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \ \ 

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (vector-ref #(1 2 3) "2"))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <subsection|迭代>

  <label|r7rs><paragraph|vector-map><index|vector-map>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define (vector-map p . args) (apply vector (apply map p args)))

    \;
  </scm-chunk>

  <label|r7rs><paragraph|vector-for-each><scm|(proc vector1 [vector2 ...])><index|vector-for-each>

  <subparagraph|实现>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define vector-for-each for-each)

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (check

    \ \ (let ((lst (make-list 5)))

    \ \ \ \ (vector-for-each

    \ \ \ \ \ \ (lambda (i) (list-set! lst i (* i i)))

    \ \ \ \ \ \ #(0 1 2 3 4))

    \ \ \ \ lst)

    \ \ =\<gtr\> '(0 1 4 9 16))

    \;

    (check

    \ \ (let ((lst (make-list 5)))

    \ \ \ \ (vector-for-each

    \ \ \ \ \ \ (lambda (i) (list-set! lst i (* i i)))

    \ \ \ \ \ \ #(0 1 2))

    \ \ \ \ lst)

    \ \ =\<gtr\> '(0 1 4 #f #f))

    \;

    (check

    \ \ (let ((lst (make-list 5)))

    \ \ \ \ (vector-for-each

    \ \ \ \ \ \ (lambda (i) (list-set! lst i (* i i)))

    \ \ \ \ \ \ #())

    \ \ \ \ lst)

    \ \ =\<gtr\> '(#f #f #f #f #f))

    \;
  </scm-chunk>

  <paragraph|vector-count><index|vector-count>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|true|true>
    ; TODO optional parameters

    (define (vector-count pred v)

    \ \ (let loop ((i 0) (count 0))

    \ \ \ \ \ \ \ (cond ((= i (vector-length v)) count)

    \ \ \ \ \ \ \ \ \ \ \ \ \ ((pred (vector-ref v i))\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) (+ count 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (+ i 1) count)))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (check (vector-count even? #()) =\<gtr\> 0)

    (check (vector-count even? #(1 3 5 7 9)) =\<gtr\> 0)

    (check (vector-count even? #(1 3 4 7 8)) =\<gtr\> 2)

    \;
  </scm-chunk>

  <subsection|搜索>

  <paragraph|vector-any><index|vector-any>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|true|true>
    ; TODO optional parameters

    (define (vector-any pred v)

    \ \ (let loop ((i 0))

    \ \ \ \ \ \ \ (cond ((= i (vector-length v)) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ \ ((pred (vector-ref v i)) #t)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (+ i 1))))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (check (vector-any even? #()) =\<gtr\> #f)

    (check (vector-any even? #(1 3 5 7 9)) =\<gtr\> #f)

    (check (vector-any even? #(1 3 4 7 8)) =\<gtr\> #t)

    \;
  </scm-chunk>

  <paragraph|vector-every><index|vector-every>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|true|true>
    ; TODO optional parameters

    (define (vector-every pred v)

    \ \ (let loop ((i 0))

    \ \ \ \ \ \ \ (cond ((= i (vector-length v)) #t)

    \ \ \ \ \ \ \ \ \ \ \ \ \ ((not (pred (vector-ref v i))) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (+ i 1))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (check (vector-every odd? #()) =\<gtr\> #t)

    (check (vector-every odd? #(1 3 5 7 9)) =\<gtr\> #t)

    (check (vector-every odd? #(1 3 4 7 8)) =\<gtr\> #f)

    \;
  </scm-chunk>

  <paragraph|vector-index><index|vector-index>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|true|true>
    ; TODO optional parameters

    (define (vector-index pred v)

    \ \ (let loop ((i 0))

    \ \ \ \ \ \ \ (cond ((= i (vector-length v)) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ \ ((pred (vector-ref v i)) i)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (+ i 1))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (check (vector-index even? #()) =\<gtr\> #f)

    (check (vector-index even? #(1 3 5 7 9)) =\<gtr\> #f)

    (check (vector-index even? #(1 3 4 7 8)) =\<gtr\> 2)

    \;
  </scm-chunk>

  <paragraph|vector-index-right><index|vector-index-right>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|true|true>
    ; TODO optional parameters

    (define (vector-index-right pred v)

    \ \ (let ((len (vector-length v)))

    \ \ \ \ (let loop ((i (- len 1)))

    \ \ \ \ \ \ \ \ \ (cond ((\<less\> i 0) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((pred (vector-ref v i)) i)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (- i 1)))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (check (vector-index-right even? #()) =\<gtr\> #f)

    (check (vector-index-right even? #(1 3 5 7 9)) =\<gtr\> #f)

    (check (vector-index-right even? #(1 3 4 7 8)) =\<gtr\> 4)

    \;
  </scm-chunk>

  <paragraph|vector-partition><index|vector-partition>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|true|true>
    (define (vector-partition pred v)

    \ \ (let* ((len (vector-length v))

    \ \ \ \ \ \ \ \ \ (cnt (vector-count pred v))

    \ \ \ \ \ \ \ \ \ (ret (make-vector len)))

    \ \ \ \ (let loop ((i 0) (yes 0) (no cnt))

    \ \ \ \ \ \ (if (= i len)

    \ \ \ \ \ \ \ \ (values ret cnt)

    \ \ \ \ \ \ \ \ (let ((elem (vector-ref v i)))

    \ \ \ \ \ \ \ \ \ \ (if (pred elem)

    \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! ret yes elem)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) (+ yes 1) no))

    \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! ret no elem)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ i 1) yes (+ no 1)))))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (define (vector-partition-\<gtr\>list pred v)

    \ \ (let-values (((ret cnt) (vector-partition pred v))) (list ret cnt)))

    \;

    (check (vector-partition-\<gtr\>list even? #()) =\<gtr\> '(#() 0))

    (check (vector-partition-\<gtr\>list even? #(1 3 5 7 9)) =\<gtr\> '(#(1 3 5 7 9) 0))

    (check (vector-partition-\<gtr\>list even? #(1 3 4 7 8)) =\<gtr\> '(#(4 8 1 3 7) 2))

    \;
  </scm-chunk>

  <subsection|修改器>

  <label|r7rs><paragraph|vector-set!><scm|(vector-set! v k obj )><index|vector-set!>

  该函数将对象 obj 存储到向量中索引为 k 的元素里。注意，返回的不是向量，而是那个 obj。当 k 不是向量的有效索引，报错。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (define my-vector #(0 1 2 3))

    (check my-vector =\<gtr\> #(0 1 2 3))

    \;

    (check (vector-set! my-vector 2 10) =\<gtr\> 10)

    (check my-vector =\<gtr\> #(0 1 10 3))

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (vector-set! my-vector 4 10))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  <paragraph|vector-swap!><index|vector-swap!>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|true|true>
    (define (vector-swap! vec i j)

    \ \ (let ((elem-i (vector-ref vec i))

    \ \ \ \ \ \ \ \ (elem-j (vector-ref vec j)))

    \ \ \ \ (vector-set! vec i elem-j)

    \ \ \ \ (vector-set! vec j elem-i)

    \ \ \ \ ))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (define my-vector (vector 0 1 2 3))

    (vector-swap! my-vector 1 2)

    (check my-vector =\<gtr\> #(0 2 1 3))

    \;

    (define my-vector (vector 0 1 2 3))

    (vector-swap! my-vector 1 1)

    (check my-vector =\<gtr\> #(0 1 2 3))

    \;

    (define my-vector (vector 0 1 2 3))

    (vector-swap! my-vector 0 (- (vector-length my-vector) 1))

    (check my-vector =\<gtr\> #(3 1 2 0))

    \;

    (check-catch

    \ 'out-of-range

    \ (vector-swap! my-vector 1 (vector-length my-vector)))

    \;
  </scm-chunk>

  <label|r7rs><paragraph|vector-fill!><index|vector-fill!>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define vector-fill! fill!)

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (define my-vector (vector 0 1 2 3 4))

    (fill! my-vector #f)

    (check my-vector =\<gtr\> #(#f #f #f #f #f))\ 

    \;

    (define my-vector (vector 0 1 2 3 4))

    (fill! my-vector #f 1 2)

    (check my-vector =\<gtr\> #(0 #f 2 3 4))\ 

    \;
  </scm-chunk>

  <label|r7rs><paragraph|vector-copy!><scm|(vector-copy! to at from [start [end]])><index|vector-copy!>

  <scm|to>和<scm|from>都是向量，<scm|vector-copy!>就是从<scm|from>向量复制元素依次粘贴到<scm|to>向量，粘贴从<scm|to>向量的第<scm|at>个索引位置开始；<scm|start>和<scm|end>是可选参数，用于指定从<scm|from>向量选取元素的范围。

  <\scm-code>
    a (vector "a0" "a1" "a2" "a3" "a4")

    b (vector "b0" "b1" "b2" "b3" "b4"

    \;

    (vector-copy! b 1 a 0 2) 就是：

    第一步：从a中选取索引为[0,2)的元素，即"a0" "a1"

    第二步：定位到b的索引为 1 的位置，即"b1"所在的那个位置

    第二步：以刚刚定位到的那个"b1"位置为起点，把刚刚选出的元素"a0" "a1"依次替换，直到

    \;

    \;

    代码实现时要注意

    at、to、from的边界条件，按顺序写它们会导致报错的条件

    要注意每一个参数在后面会遇到怎样的使用

    \;

    第一步：只涉及单个参数的报错条件

    (\<less\> at 0) 可省去

    (\<gtr\> at (vector-length to)) 可省去

    (\<less\> start 0)

    (\<less\> start 0)

    (\<gtr\> start (vector-length from))

    (\<less\> end 0)

    (\<gtr\> end (vector-length from))

    \;

    第二步：两个依赖关系的参数的报错条件

    (\<gtr\> start end)

    \;

    第三步：三个依赖关系参数的报错条件

    (\<gtr\> (+ at (- end start)) (vector-length to))

    \;

    综合上方的报错条件，去掉一些多余的条件：

    (\<less\> start 0)可省去

    因为有(\<gtr\> (+ at (- end start)) (vector-length to))，所以(\<gtr\> at (vector-length to))可省去
  </scm-code>

  <\session|guile|default>
    <\input>
      \<gtr\>\ 
    <|input>
      (define a (vector "a0" "a1" "a2" "a3" "a4"))
    </input>

    <\input>
      \<gtr\>\ 
    <|input>
      (define b (vector "b0" "b1" "b2" "b3" "b4"))
    </input>

    <\input>
      \<gtr\>\ 
    <|input>
      (vector-copy! b 0 a 1)
    </input>

    <\unfolded-io>
      \<gtr\>\ 
    <|unfolded-io>
      b
    <|unfolded-io>
      <guile-result|#("a1" "a2" "a3" "a4" "b4")>
    </unfolded-io>

    <\unfolded-io>
      \<gtr\>\ 
    <|unfolded-io>
      a
    <|unfolded-io>
      <guile-result|#("a0" "a1" "a2" "a3" "a4")>
    </unfolded-io>

    <\input>
      \<gtr\>\ 
    <|input>
      \;
    </input>
  </session>

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    (define* (vector-copy! to at from (start 0) (end (vector-length from)))

    \ \ (if (or (\<less\> at 0)

    \ \ \ \ \ \ \ \ \ \ (\<gtr\> start (vector-length from))

    \ \ \ \ \ \ \ \ \ \ (\<less\> end 0)

    \ \ \ \ \ \ \ \ \ \ (\<gtr\> end (vector-length from))

    \ \ \ \ \ \ \ \ \ \ (\<gtr\> start end)

    \ \ \ \ \ \ \ \ \ \ (\<gtr\> (+ at (- end start)) (vector-length to)))

    \ \ \ \ \ \ (error 'out-of-range "vector-copy!")

    \ \ \ \ \ \ (let loop ((to-i at) (from-i start))

    \ \ \ \ \ \ \ \ (if (\<gtr\>= from-i end)

    \ \ \ \ \ \ \ \ \ \ \ \ to

    \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (vector-set! to to-i (vector-ref from from-i))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (loop (+ to-i 1) (+ from-i 1)))))))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (define a (vector "a0" "a1" "a2" "a3" "a4"))

    (define b (vector "b0" "b1" "b2" "b3" "b4"))

    \;

    ;(\<less\> at 0)

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (vector-copy! b -1 a))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    ;(\<less\> start 0)

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (vector-copy! b 0 a -1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    ;(\<gtr\> start (vector-length from))

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (vector-copy! b 0 a 6))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    ;(\<gtr\> end (vector-length from))

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (vector-copy! b 0 a 0 6))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    ;(\<gtr\> start end)

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (vector-copy! b 0 a 2 1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    ;(\<gtr\> (+ at (- end start)) (vector-length to))

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (vector-copy! b 6 a))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (vector-copy! b 1 a))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (define a (vector "a0" "a1" "a2" "a3" "a4"))

    (define b (vector "b0" "b1" "b2" "b3" "b4"))

    (vector-copy! b 0 a 1)

    (check b =\<gtr\> #("a1" "a2" "a3" "a4" "b4"))

    \;

    (define a (vector "a0" "a1" "a2" "a3" "a4"))

    (define b (vector "b0" "b1" "b2" "b3" "b4"))

    (vector-copy! b 0 a 0 5)

    (check b =\<gtr\> #("a0" "a1" "a2" "a3" "a4"))\ 

    \;
  </scm-chunk>

  <subsection|转换>

  <label|r7rs><paragraph|vector-\<gtr\>list><scm|(vector-\<gtr\>list v [start [end]])><index|vector-\<gtr\>list>

  返回一个新分配的列表，包含向量中从 start 到 end 之间的元素中的对象。当 <scm|start>、<scm|end>不是向量的有效索引，报错。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|true>
    (check (vector-\<gtr\>list #()) =\<gtr\> '())

    (check (vector-\<gtr\>list #() 0) =\<gtr\> '())

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (vector-\<gtr\>list #() 1))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check (vector-\<gtr\>list #(0 1 2 3)) =\<gtr\> '(0 1 2 3))

    (check (vector-\<gtr\>list #(0 1 2 3) 1) =\<gtr\> '(1 2 3))

    (check (vector-\<gtr\>list #(0 1 2 3) 1 1) =\<gtr\> '())

    (check (vector-\<gtr\>list #(0 1 2 3) 1 2) =\<gtr\> '(1))

    \;
  </scm-chunk>

  \;

  <label|r7rs><paragraph|list-\<gtr\>vector><scm|(list-\<gtr\>vector l)><index|list-\<gtr\>vector>

  返回一个新创建的向量，其元素初始化为列表 <code*|list> 中的元素。注意，<item*|list-\<gtr\>vector>不像<item*|vector-\<gtr\>list>那样可用接收索引参数。

  <\scm-chunk|tests/goldfish/liii/base-test.scm|true|false>
    (check (list-\<gtr\>vector '(0 1 2 3)) =\<gtr\> #(0 1 2 3))

    (check (list-\<gtr\>vector '()) =\<gtr\> #())

    \;
  </scm-chunk>

  \;

  <label|r7rs><paragraph|vector-\<gtr\>string><scm|(v [start [end]]) =\<gtr\> string><index|vector-\<gtr\>string>

  将向量v转化为字符串，如果指定了起始索引和终止索引，则只将指定范围内的子向量转化为字符串。

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    ; 0-clause BSD

    ; Bill Schottstaedt

    ; from S7 source repo: r7rs.scm

    (define* (vector-\<gtr\>string v (start 0) end)\ 

    \ \ (let ((stop (or end (length v))))\ 

    \ \ \ \ (copy v (make-string (- stop start)) start stop)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (check (vector-\<gtr\>string (vector #\\0 #\\1 #\\2 #\\3)) =\<gtr\> "0123")

    (check (vector-\<gtr\>string (vector #\\a #\\b #\\c)) =\<gtr\> "abc")

    \;

    (check (vector-\<gtr\>string (vector #\\0 #\\1 #\\2 #\\3) 0 4) =\<gtr\> "0123")

    (check (vector-\<gtr\>string (vector #\\0 #\\1 #\\2 #\\3) 1) =\<gtr\> "123")

    (check (vector-\<gtr\>string (vector #\\0 #\\1 #\\2 #\\3) 1 4) =\<gtr\> "123")

    (check (vector-\<gtr\>string (vector #\\0 #\\1 #\\2 #\\3) 1 3) =\<gtr\> "12")

    (check (vector-\<gtr\>string (vector #\\0 #\\1 #\\2 #\\3) 1 2) =\<gtr\> "1")

    \;

    (check

    \ \ (catch 'out-of-range

    \ \ \ \ (lambda () (vector-\<gtr\>string (vector #\\0 #\\1 #\\2 #\\3) 2 10))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;

    (check (vector-\<gtr\>string (vector 0 1 #\\2 3 4) 2 3) =\<gtr\> "2")

    \;

    (check

    \ \ (catch 'wrong-type-arg

    \ \ \ \ (lambda () (vector-\<gtr\>string (vector 0 1 #\\2 3 4) 1 3))

    \ \ \ \ (lambda args #t))

    \ \ =\<gtr\>

    \ \ #t)

    \;
  </scm-chunk>

  \;

  <label|r7rs><paragraph|string-\<gtr\>vector><scm|(s [start [end]]) =\<gtr\> vector><index|string-\<gtr\>vector>

  将字符串s转化为向量，如果指定了起始索引和终止索引，则只将指定范围内的子字符串转化为向量。

  <\scm-chunk|goldfish/scheme/base.scm|true|true>
    ; 0-clause BSD

    ; Bill Schottstaedt

    ; from S7 source repo: r7rs.scm

    (define* (string-\<gtr\>vector s (start 0) end)

    \ \ (let ((stop (or end (length s))))\ 

    \ \ \ \ (copy s (make-vector (- stop start)) start stop)))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|true>
    (check (string-\<gtr\>vector "0123") =\<gtr\> (vector #\\0 #\\1 #\\2 #\\3))

    (check (string-\<gtr\>vector "abc") =\<gtr\> (vector #\\a #\\b #\\c))

    \;

    (check (string-\<gtr\>vector "0123" 0 4) =\<gtr\> (vector #\\0 #\\1 #\\2 #\\3))

    (check (string-\<gtr\>vector "0123" 1) =\<gtr\> (vector #\\1 #\\2 #\\3))

    (check (string-\<gtr\>vector "0123" 1 4) =\<gtr\> (vector #\\1 #\\2 #\\3))

    (check (string-\<gtr\>vector "0123" 1 3) =\<gtr\> (vector #\\1 #\\2))

    (check (string-\<gtr\>vector "0123" 1 2) =\<gtr\> (vector #\\1))

    \;

    (check-catch 'out-of-range (string-\<gtr\>vector "0123" 2 10))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/srfi/srfi-133.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/vector.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/vector-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii stack)>

  栈是一个先进后出（FILO）的数据结构。

  这个函数库是三鲤自定义的库，参考了C++和Java的栈相关的函数库的接口。

  <section|许可证>

  <\scm-chunk|goldfish/liii/stack.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define-library (liii stack)

    (import (srfi srfi-9)

    \ \ \ \ \ \ \ \ (liii base)

    \ \ \ \ \ \ \ \ (liii error))

    (export

    \ stack

    \ stack? stack-empty?

    \ stack-size stack-top

    \ stack-push! stack-pop!

    \ stack-\<gtr\>list

    )

    (begin

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/stack-test.scm|false|false>
    (import (liii stack)

    \ \ \ \ \ \ \ \ (liii check))

    \;

    (check-set-mode! 'report-failed)

    \;

    (define stack1 (stack))

    (check (stack-empty? stack1) =\<gtr\> #t)

    (check (stack-\<gtr\>list stack1) =\<gtr\> '())

    (check-catch 'value-error (stack-pop! stack1))

    \;

    (stack-push! stack1 1)

    (check (stack-\<gtr\>list stack1) =\<gtr\> '(1))

    (check (stack-top stack1) =\<gtr\> 1)

    (check (stack-size stack1) =\<gtr\> 1)

    (check (stack-pop! stack1) =\<gtr\> 1)

    (check (stack-empty? stack1) =\<gtr\> #t)

    (check (stack-size stack1) =\<gtr\> 0)

    \;

    (define stack2 (stack 1 2 3))

    (check (stack-\<gtr\>list stack2) =\<gtr\> '(1 2 3))

    (check (stack-size stack2) =\<gtr\> 3)

    (check (stack-pop! stack2) =\<gtr\> 1)

    (check (stack-pop! stack2) =\<gtr\> 2)

    (check (stack-pop! stack2) =\<gtr\> 3)

    \;

    (define stack3 (stack ))

    (stack-push! stack3 1)

    (stack-push! stack3 2)

    (stack-push! stack3 3)

    (check (stack-pop! stack3) =\<gtr\> 3)

    (check (stack-pop! stack3) =\<gtr\> 2)

    (check (stack-pop! stack3) =\<gtr\> 1)

    \;

    (check-catch 'type-error (stack-empty? 1))

    \;
  </scm-chunk>

  <section|实现>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define-record-type :stack

    \ \ (make-stack data)

    \ \ stack?

    \ \ (data get-data set-data!))

    \;

    (define (%stack-check-parameter st)

    \ \ (when (not (stack? st))

    \ \ \ \ (error 'type-error "Parameter st is not a stack")))

    \;
  </scm-chunk>

  <paragraph|stack><index|stack><scm|(x1 x2 ...) =\<gtr\> stack>

  传入参数，构造一个栈，第一个参数是栈顶。如果没有参数，则构造的是空栈。

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack . l)

    \ \ (if (null? l)

    \ \ \ \ \ \ (make-stack '())

    \ \ \ \ \ \ (make-stack l)))

    \;
  </scm-chunk>

  <paragraph|stack-empty?><index|stack-empty?><scm|(st) =\<gtr\> bool>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-empty? st)

    \ \ (%stack-check-parameter st)

    \ \ (null? (get-data st)))

    \;
  </scm-chunk>

  <paragraph|stack-size><index|stack-size><scm|(st) =\<gtr\> int>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-size st)

    \ \ (%stack-check-parameter st)

    \ \ (length (get-data st)))

    \;
  </scm-chunk>

  <paragraph|stack-top><index|stack-top><scm|(st) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-top st)

    \ \ (%stack-check-parameter st)

    \ \ (car (get-data st)))

    \;
  </scm-chunk>

  <paragraph|stack-push!><index|stack-push!><scm|(st x) =\<gtr\> #\<less\>unspecified\<gtr\>>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-push! st elem)

    \ \ (%stack-check-parameter st)

    \ \ (set-data! st (cons elem (get-data st))))

    \;
  </scm-chunk>

  <paragraph|stack-pop!><index|stack-pop!><scm|(st) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-pop! st)

    \ \ (%stack-check-parameter st)

    \ \ (when (stack-empty? st)

    \ \ \ \ (error 'value-error "Failed to stack-pop! on empty stack"))

    \ \ (let1 data (get-data st)

    \ \ \ \ (set-data! st (cdr data))

    \ \ \ \ (car data)))

    \;
  </scm-chunk>

  <paragraph|stack-\<gtr\>list><index|stack-\<gtr\>list><scm|(st) =\<gtr\> list>

  <\scm-chunk|goldfish/liii/stack.scm|true|true>
    (define (stack-\<gtr\>list st)

    \ \ (%stack-check-parameter st)

    \ \ (get-data st))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/stack.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <chapter|(liii queue)>

  这个函数库是三鲤自定义的库，参考了C++和Java的队列相关的函数库的接口。目前基于Scheme的列表实现，从队列取出数据的复杂度是<math|O<around*|(|1|)>>，从队列存入数据的复杂度是<math|O<around*|(|n|)>>。

  <section|许可证>

  <\scm-chunk|goldfish/liii/queue.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/queue-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define-library (liii queue)

    (import (liii list)

    \ \ \ \ \ \ \ \ (liii base)

    \ \ \ \ \ \ \ \ (srfi srfi-9)

    \ \ \ \ \ \ \ \ (liii error))

    (export

    \ \ queue

    \ \ queue? queue-empty?

    \ \ queue-size queue-front queue-back

    \ \ queue-pop! queue-push!

    \ \ queue-\<gtr\>list)

    (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/queue-test.scm|true|true>
    (import (liii queue)

    \ \ \ \ \ \ \ \ (liii base)

    \ \ \ \ \ \ \ \ (liii check))

    \;

    (check-set-mode! 'report-failed)

    \;

    (let1 q1 (queue)

    \ \ (check-true (queue-empty? q1))

    \ \ (check (queue-size q1) =\<gtr\> 0)

    \ \ (check-catch 'value-error (queue-pop! q1))

    \;

    \ \ (queue-push! q1 1)

    \ \ (check (queue-size q1) =\<gtr\> 1)

    \ \ (check (queue-front q1) =\<gtr\> 1)

    \ \ (check (queue-back q1) =\<gtr\> 1)

    \ \ (check (queue-pop! q1) =\<gtr\> 1)

    \ \ (check-true (queue-empty? q1))

    )

    \;

    (let1 q2 (queue 1 2 3)

    \ \ (check (queue-size q2) =\<gtr\> 3)

    \ \ (check (queue-front q2) =\<gtr\> 1)

    \ \ (check (queue-back q2) =\<gtr\> 3)

    \ \ (check (queue-pop! q2) =\<gtr\> 1)

    \ \ (check (queue-pop! q2) =\<gtr\> 2)

    \ \ (check (queue-pop! q2) =\<gtr\> 3)

    )

    \;
  </scm-chunk>

  <section|实现>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define-record-type :queue

    \ \ (make-queue data)

    \ \ queue?

    \ \ (data get-data set-data!))

    \;

    (define (%queue-assert-type q)

    \ \ (when (not (queue? q))

    \ \ \ \ (type-error "Parameter q is not a queue")))

    \;

    (define (%queue-assert-value q)

    \ \ (when (queue-empty? q)

    \ \ \ \ (value-error "q must be non-empty")))

    \;
  </scm-chunk>

  <paragraph|queue><index|queue>

  第一个参数是队列的头部，最后一个参数是队列的尾部。

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue . l)

    \ \ (if (null? l)

    \ \ \ \ \ \ (make-queue '())

    \ \ \ \ \ \ (make-queue l)))

    \;
  </scm-chunk>

  <paragraph|queue-empty?><index|queue-empty?><scm|(queue) =\<gtr\> bool>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-empty? q)

    \ \ (%queue-assert-type q)

    \ \ (null? (get-data q)))

    \;
  </scm-chunk>

  <paragraph|queue-size><index|queue-size><scm|(queue) =\<gtr\> int>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-size q)

    \ \ (%queue-assert-type q)

    \ \ (length (get-data q)))

    \;
  </scm-chunk>

  <paragraph|queue-front><index|queue-front><scm|(queue) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-front q)

    \ \ (%queue-assert-type q)

    \ \ (%queue-assert-value q)

    \ \ (first (get-data q)))

    \;
  </scm-chunk>

  <paragraph|queue-back><index|queue-back><scm|(queue) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-back q)

    \ \ (%queue-assert-type q)

    \ \ (%queue-assert-value q)

    \ \ (last (get-data q)))

    \;
  </scm-chunk>

  <paragraph|queue-push!><index|queue-push!><scm|(queue x) =\<gtr\> queue>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-push! q x)

    \ \ (%queue-assert-type q)

    \ \ (let1 data (get-data q)

    \ \ \ \ (set-data! q (append data (list x)))))

    \;
  </scm-chunk>

  <paragraph|queue-pop!><index|queue-pop!><scm|(queue) =\<gtr\> x>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-pop! q)

    \ \ (%queue-assert-type q)

    \ \ (%queue-assert-value q)

    \ \ (let1 data (get-data q)

    \ \ \ \ (set-data! q (cdr data))

    \ \ \ \ (car data)))

    \;
  </scm-chunk>

  <paragraph|queue-\<gtr\>list><index|queue-\<gtr\>list><scm|(queue) =\<gtr\> list>

  <\scm-chunk|goldfish/liii/queue.scm|true|true>
    (define (queue-\<gtr\>list q)

    \ \ (get-data q))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/liii/queue.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/queue-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii hash-table)>

  <section|许可证>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/hash-table.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (import (liii check)

    \ \ \ \ \ \ \ \ (liii hash-table)

    \ \ \ \ \ \ \ \ (liii base))

    \;

    (check-set-mode! 'report-failed)

    \;

    (define empty-ht (make-hash-table))

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define-library (srfi srfi-125)

    (import (srfi srfi-1))

    (export

    \ \ make-hash-table, hash-table, hash-table-unfold, alist-\<gtr\>hash-table

    \ \ hash-table? hash-table-contains? hash-table-empty? hash-table=?

    \ \ hash-table-mutable?

    \ \ hash-table-ref hash-table-ref/default

    \ \ hash-table-set! hash-table-delete! hash-table-intern! hash-table-update!

    \ \ hash-table-update!/default hash-table-pop! hash-table-clear!

    \ \ hash-table-size hash-table-keys hash-table-values hash-table-entries

    \ \ hash-table-find hash-table-count

    )

    (begin

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/hash-table.scm|true|true>
    (define-library (liii hash-table)

    (import (srfi srfi-125))

    (export

    \ \ make-hash-table, hash-table, hash-table-unfold, alist-\<gtr\>hash-table

    \ \ hash-table? hash-table-contains? hash-table-empty? hash-table=?

    \ \ hash-table-mutable?

    \ \ hash-table-ref hash-table-ref/default

    \ \ hash-table-set! hash-table-delete! hash-table-intern! hash-table-update!

    \ \ hash-table-update!/default hash-table-pop! hash-table-clear!

    \ \ hash-table-size hash-table-keys hash-table-values hash-table-entries

    \ \ hash-table-find hash-table-count

    )

    (begin
  </scm-chunk>

  <subsection|访问哈希表中的元素>

  除了SRFI 125定义的<scm|hash-table-ref>和<scm|hash-table-ref/default>之外，我们可以用S7 Scheme内置的访问方式：

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (check (ht 'a) =\<gtr\> #f)

    \ \ (hash-table-set! ht 'a 1)

    \ \ (check (ht 'a) =\<gtr\> 1))

    \;
  </scm-chunk>

  <section|实现>

  <subsection|子函数>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (assert-hash-table-type ht f)

    \ \ (when (not (hash-table? ht))

    \ \ \ \ (error 'type-error f "this parameter must be typed as hash-table")))

    \;

    (define hash-table-set-s7 hash-table-set!)

    \;
  </scm-chunk>

  <subsection|构造器>

  <paragraph|make-hash-table>

  <paragraph|hash-table>

  <subsection|谓词>

  <paragraph|hash-table?><index|hash-table?>

  S7内置函数。判断一个对象是不是哈希表。

  <paragraph|hash-table-contains?><index|hash-table-contains?><scm|(hash-table key) =\<gtr\> bool>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-contains? ht key)

    \ \ (not (not (hash-table-ref ht key))))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (hash-table-set! ht 'brand 'liii)

    \ \ (check (hash-table-contains? ht 'brand) =\<gtr\> #t)

    \ \ (hash-table-set! ht 'brand #f)

    \ \ (check (hash-table-contains? ht 'brand) =\<gtr\> #f))

    \;
  </scm-chunk>

  <paragraph|hash-table-empty?><index|hash-table-empty?>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-empty? ht)

    \ \ (zero? (hash-table-size ht)))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (check (hash-table-empty? empty-ht) =\<gtr\> #t)

    \;

    (let1 test-ht (make-hash-table)

    \ \ (hash-table-set! test-ht 'key 'value)

    \ \ (check (hash-table-empty? test-ht) =\<gtr\> #f))

    \;
  </scm-chunk>

  <paragraph|hash-table=?><index|hash-table=?><scm|(ht1 ht2) =\<gtr\> boolean>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table=? ht1 ht2)

    \ \ (equal? ht1 ht2))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let ((empty-h1 (make-hash-table))

    \ \ \ \ \ \ (empty-h2 (make-hash-table)))

    \ \ (check (hash-table=? empty-h1 empty-h2) =\<gtr\> #t))

    \;

    (let ((t1 (make-hash-table))

    \ \ \ \ \ \ (t2 (make-hash-table)))

    \ \ (hash-table-set! t1 'a 1)

    \ \ (hash-table-set! t2 'a 1)

    \ \ (check (hash-table=? t1 t2) =\<gtr\> #t)

    \ \ (hash-table-set! t1 'b 2)

    \ \ (check (hash-table=? t1 t2) =\<gtr\> #f))

    \;
  </scm-chunk>

  <subsection|选择器>

  <paragraph|hash-table-ref><index|hash-table-ref><scm|(hash-table-ref ht key) =\<gtr\> value>

  <\description>
    <item*|ht>哈希表

    <item*|key>键

    <item*|value>返回hash表中key这个键对应的值
  </description>

  SRFI 125定义的<scm|hash-table-ref>的函数签名是这样的：<scm|(hash-table-ref hash-table key [failure [success]])>。两参数形式的<scm|hash-table-ref>是S7 Scheme的内置函数。

  在S7 Scheme中，可以直接将hash-table视作一个单参数的函数，比如<scm|(ht 'key)>等价于<scm|(hash-table-ref ht 'key)>。

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (check (hash-table-ref empty-ht 'key) =\<gtr\> #f)

    \;

    (let1 ht (make-hash-table)

    \ \ (hash-table-set! ht 'key 'value)

    \ \ (check (hash-table-ref ht 'key) =\<gtr\> 'value)

    \ \ (check (ht 'key) =\<gtr\> 'value))

    \;
  </scm-chunk>

  <paragraph|hash-table-ref/default><index|hash-table-ref/default><scm|(hash-table-ref/default ht key default) =\<gtr\> value>

  <\description>
    <item*|ht>哈希表

    <item*|key>键

    <item*|default>默认值，如果key这个键在哈希表中对应的值不存在，则返回默认值。注意，该默认值只有在key这个键不存在的时候，才会被求值。

    <item*|value>键对应的值，如果不存在，则为默认值。
  </description>

  <subparagraph|测试>

  当键对应的值存在时，default不会被求值，故而测试中的<scm|(display "hello")>实际不会被执行。

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (check (hash-table-ref/default ht 'key 'value1) =\<gtr\> 'value1)

    \ \ (check (hash-table-ref/default ht 'key (+ 1 2)) =\<gtr\> 3)

    \;

    \ \ (hash-table-set! ht 'key 'value)

    \ \ (check (hash-table-ref/default ht 'key

    \ \ \ \ \ \ \ \ \ \ \ (begin (display "hello")

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (+ 1 2)))

    \ \ \ \ =\<gtr\> 'value)

    ) ; end of let1

    \;
  </scm-chunk>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define-macro (hash-table-ref/default ht key default)

    \ \ ‘(or (hash-table-ref ,ht ,key)

    \ \ \ \ \ \ \ \ ,default))

    \;
  </scm-chunk>

  <subsection|修改器>

  <paragraph|hash-table-set!><index|hash-table-set!>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (hash-table-set! ht 'k1 'v1 'k2 'v2)

    \ \ (check (ht 'k1) =\<gtr\> 'v1)

    \ \ (check (ht 'k2) =\<gtr\> 'v2)

    )

    \;
  </scm-chunk>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-set! ht . rest)

    \ \ (assert-hash-table-type ht hash-table-set!)

    \ \ (let1 len (length rest)

    \ \ \ \ (when (or (odd? len) (zero? len))

    \ \ \ \ \ \ (error 'wrong-number-of-args len "but must be even and non-zero"))

    \ \ \ \ 

    \ \ \ \ (hash-table-set-s7 ht (car rest) (cadr rest))

    \ \ \ \ (when (\<gtr\> len 2)

    \ \ \ \ \ \ \ \ \ \ (apply hash-table-set! (cons ht (cddr rest))))))

    \;
  </scm-chunk>

  <paragraph|hash-table-delete!><index|hash-table-delete!>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (hash-table-update! ht 'key 'value)

    \ \ (check (hash-table-delete! ht 'key) =\<gtr\> 1)

    \ \ (check-false (hash-table-contains? ht 'key))

    \ \ 

    \ \ (hash-table-update! ht 'key1 'value1)

    \ \ (hash-table-update! ht 'key2 'value2)

    \ \ (hash-table-update! ht 'key3 'value3)

    \ \ (hash-table-update! ht 'key4 'value4)

    \ \ (check (hash-table-delete! ht 'key1 'key2 'key3) =\<gtr\> 3)

    )

    \;
  </scm-chunk>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-delete! ht key . keys)

    \ \ (assert-hash-table-type ht hash-table-delete!)

    \ \ (let1 all-keys (cons key keys)

    \ \ \ \ (length

    \ \ \ \ \ \ (filter

    \ \ \ \ \ \ \ \ (lambda (x)

    \ \ \ \ \ \ \ \ \ \ (if (hash-table-contains? ht x)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ (begin

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (hash-table-set-s7 ht x #f)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ #t)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ #f))

    \ \ \ \ \ \ \ \ all-keys))))

    \;
  </scm-chunk>

  <paragraph|hash-table-update!><index|hash-table-update!>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-update! ht key value)

    \ \ (hash-table-set! ht key value))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (hash-table-update! ht 'key 'value)

    \ \ (check (ht 'key) =\<gtr\> 'value)

    \ \ (hash-table-update! ht 'key 'value1)

    \ \ (check (ht 'key) =\<gtr\> 'value1)

    \ \ (hash-table-update! ht 'key #f)

    \ \ (check (ht 'key) =\<gtr\> #f))

    \;
  </scm-chunk>

  <paragraph|hash-table-clear!><index|hash-table-clear!>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-clear! ht)

    \ \ (for-each

    \ \ \ \ (lambda (key)

    \ \ \ \ \ \ (hash-table-set! ht key #f))

    \ \ \ \ (hash-table-keys ht)))

    \;
  </scm-chunk>

  \;

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (let1 ht (make-hash-table)

    \ \ (hash-table-update! ht 'key 'value)

    \ \ (hash-table-update! ht 'key1 'value1)

    \ \ (hash-table-update! ht 'key2 'value2)

    \ \ (hash-table-clear! ht)

    \ \ (check-true (hash-table-empty? ht)))

    \;
  </scm-chunk>

  <subsection|哈希表整体>

  <paragraph|hash-table-size><index|hash-table-size>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define hash-table-size hash-table-entries)

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (check (hash-table-size empty-ht) =\<gtr\> 0)

    \;

    (let1 populated-ht (make-hash-table)

    \ \ (hash-table-set! populated-ht 'key1 'value1)

    \ \ (hash-table-set! populated-ht 'key2 'value2)

    \ \ (hash-table-set! populated-ht 'key3 'value3)

    \ \ (check (hash-table-size populated-ht) =\<gtr\> 3))

    \;
  </scm-chunk>

  <paragraph|hash-table-keys><index|hash-table-keys>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-keys ht)

    \ \ (map car (map values ht)))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (check (hash-table-keys empty-ht) =\<gtr\> '())

    \;

    (let1 ht (make-hash-table)

    \ \ (hash-table-set! ht 'k1 'v1)

    \ \ (check (hash-table-keys ht) =\<gtr\> '(k1)))

    \;
  </scm-chunk>

  <paragraph|hash-table-values><index|hash-table-values>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-values ht)

    \ \ (map cdr (map values ht)))

    \;
  </scm-chunk>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|true>
    (check (hash-table-values empty-ht) =\<gtr\> '())

    \;

    (let1 ht (make-hash-table)

    \ \ (hash-table-set! ht 'k1 'v1)

    \ \ (check (hash-table-values ht) =\<gtr\> '(v1)))

    \;
  </scm-chunk>

  <subsection|复制和转换>

  <paragraph|hash-table-\<gtr\>alist><index|hash-table-\<gtr\>alist>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|true>
    (define (hash-table-\<gtr\>alist table)

    \ \ (map values table))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|tests/goldfish/liii/hash-table-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-125.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/liii/hash-table.scm|true|false>
    ) ; end of begin

    ) ; end of library

    \;
  </scm-chunk>

  <chapter|(liii comparator)>

  <section|许可证>

  SRFI 128的参考实现依赖于SRFI 39。我们可以移除SRFI 128的参考实现对于SRFI 39的依赖。

  <\scm-chunk|goldfish/srfi/srfi-128.scm|false|true>
    ;;; SPDX-License-Identifier: MIT

    ;;;

    ;;; Copyright (C) John Cowan (2015). All Rights Reserved.

    ;;;\ 

    ;;; Permission is hereby granted, free of charge, to any person

    ;;; obtaining a copy of this software and associated documentation

    ;;; files (the "Software"), to deal in the Software without

    ;;; restriction, including without limitation the rights to use,

    ;;; copy, modify, merge, publish, distribute, sublicense, and/or

    ;;; sell copies of the Software, and to permit persons to whom the

    ;;; Software is furnished to do so, subject to the following

    ;;; conditions:

    ;;;\ 

    ;;; The above copyright notice and this permission notice shall be

    ;;; included in all copies or substantial portions of the Software.

    ;;;\ 

    ;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

    ;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES

    ;;; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

    ;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT

    ;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,

    ;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING

    ;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR

    ;;; OTHER DEALINGS IN THE SOFTWARE.\ 

    \;

    ;;;; Main part of the SRFI 114 reference implementation

    \;

    ;;; "There are two ways of constructing a software design: One way is to

    ;;; make it so simple that there are obviously no deficiencies, and the

    ;;; other way is to make it so complicated that there are no *obvious*

    ;;; deficiencies." --Tony Hoare

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define-library (srfi srfi-128)

    (import (scheme base))

    (export

    \ \ make-comparator make-default-comparator

    \ \ boolean\<less\>? complex\<less\>? default-hash

    \ \ =? \<less\>? \<gtr\>? \<less\>=? \<gtr\>=?

    )

    (begin

    \;
  </scm-chunk>

  <paragraph|comparator?>

  <paragraph|comparator-ordered?>

  <paragraph|comparator-hashable?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define-record-type comparator

    \ \ (make-raw-comparator type-test equality ordering hash ordering? hash?)

    \ \ comparator?

    \ \ (type-test comparator-type-test-predicate)

    \ \ (equality comparator-equality-predicate)

    \ \ (ordering comparator-ordering-predicate)

    \ \ (hash comparator-hash-function)

    \ \ (ordering? comparator-ordered?)

    \ \ (hash? comparator-hashable?))

    \;
  </scm-chunk>

  <paragraph|comparator-test-type>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    ;; Invoke the test type

    (define (comparator-test-type comparator obj)

    \ \ ((comparator-type-test-predicate comparator) obj))

    \;
  </scm-chunk>

  <paragraph|comparator-check-type>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (comparator-check-type comparator obj)

    \ \ (if (comparator-test-type comparator obj)

    \ \ \ \ #t

    \ \ \ \ (error "comparator type check failed" comparator obj)))

    \;
  </scm-chunk>

  <paragraph|comparator-hash>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (comparator-hash comparator obj)

    \ \ ((comparator-hash-function comparator) obj))

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/liii/comparator-test.scm|false|true>
    (import (srfi srfi-128)

    \ \ \ \ \ \ \ \ (liii check)

    \ \ \ \ \ \ \ \ (liii base))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  \;

  <section|内部函数>

  <paragraph|binary=?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (binary=? comparator a b)

    \ \ ((comparator-equality-predicate comparator) a b))

    \;
  </scm-chunk>

  <paragraph|binary\<less\>?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (binary\<less\>? comparator a b)

    \ \ ((comparator-ordering-predicate comparator) a b))

    \;
  </scm-chunk>

  \;

  <paragraph|binary\<gtr\>?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (binary\<gtr\>? comparator a b)

    \ \ (binary\<less\>? comparator b a))

    \;
  </scm-chunk>

  \;

  <paragraph|binary\<less\>=?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (binary\<less\>=? comparator a b)

    \ \ (not (binary\<gtr\>? comparator a b)))

    \;
  </scm-chunk>

  \;

  <paragraph|binary\<gtr\>=?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (binary\<gtr\>=? comparator a b)

    \ \ (not (binary\<less\>? comparator a b)))

    \;
  </scm-chunk>

  <paragraph|%salt%>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define %salt%

    \ \ 16064047)

    \;
  </scm-chunk>

  <paragraph|hash-bound>

  <\equation*>
    2<rsup|25>-1
  </equation*>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (hash-bound)

    \ \ 33554432)

    \;
  </scm-chunk>

  <paragraph|make-hasher>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (make-hasher)

    \ \ (let ((result (%salt%)))

    \ \ \ \ (case-lambda

    \ \ \ \ \ (() result)

    \ \ \ \ \ ((n) (set! result (+ (modulo (* result 33) (hash-bound)) n))

    \ \ \ \ \ \ \ \ \ \ result))))

    \;
  </scm-chunk>

  <section|构造器>

  <paragraph|make-comparator><index|make-comparator>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (make-comparator type-test equality ordering hash)

    \ \ (make-raw-comparator

    \ \ \ \ (if (eq? type-test #t) (lambda (x) #t) type-test)

    \ \ \ \ (if (eq? equality #t) (lambda (x y) (eqv? (ordering x y) 0)) equality)

    \ \ \ \ (if ordering ordering (lambda (x y) (error "ordering not supported")))

    \ \ \ \ (if hash hash (lambda (x y) (error "hashing not supported")))

    \ \ \ \ (if ordering #t #f)

    \ \ \ \ (if hash #t #f)))

    \;
  </scm-chunk>

  <paragraph|make-eq-comparator><index|make-eq-comparator>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (make-eq-comparator)

    \ \ (make-comparator #t eq? #f default-hash))

    \;
  </scm-chunk>

  \;

  <paragraph|make-eqv-comparator><index|make-eqv-comparator>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (make-eqv-comparator)

    \ \ (make-comparator #t eqv? #f default-hash))

    \;
  </scm-chunk>

  \;

  <paragraph|make-equal-comparator><index|make-equal-comparator>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (make-equal-comparator)

    \ \ (make-comparator #t equal? #f default-hash))

    \;
  </scm-chunk>

  \;

  <paragraph|make-pair-comparator><index|make-pair-comparator>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (make-pair-type-test car-comparator cdr-comparator)

    \ \ (lambda (obj)

    \ \ \ \ (and (pair? obj)

    \ \ \ \ \ \ \ \ \ (comparator-test-type car-comparator (car obj))

    \ \ \ \ \ \ \ \ \ (comparator-test-type cdr-comparator (cdr obj)))))

    \;

    (define (make-pair=? car-comparator cdr-comparator)

    \ \ \ (lambda (a b)

    \ \ \ \ \ (and ((comparator-equality-predicate car-comparator) (car a) (car b))

    \ \ \ \ \ \ \ \ \ \ ((comparator-equality-predicate cdr-comparator) (cdr a) (cdr b)))))

    \;

    (define (make-pair\<less\>? car-comparator cdr-comparator)

    \ \ \ (lambda (a b)

    \ \ \ \ \ \ (if (=? car-comparator (car a) (car b))

    \ \ \ \ \ \ \ \ (\<less\>? cdr-comparator (cdr a) (cdr b))

    \ \ \ \ \ \ \ \ (\<less\>? car-comparator (car a) (car b)))))

    \;

    (define (make-pair-hash car-comparator cdr-comparator)

    \ \ \ (lambda (obj)

    \ \ \ \ \ (let ((acc (make-hasher)))

    \ \ \ \ \ \ \ (acc (comparator-hash car-comparator (car obj)))

    \ \ \ \ \ \ \ (acc (comparator-hash cdr-comparator (cdr obj)))

    \ \ \ \ \ \ \ (acc))))

    \;

    (define (make-pair-comparator car-comparator cdr-comparator)

    \ \ \ (make-comparator

    \ \ \ \ \ (make-pair-type-test car-comparator cdr-comparator)

    \ \ \ \ \ (make-pair=? car-comparator cdr-comparator)

    \ \ \ \ \ (make-pair\<less\>? car-comparator cdr-comparator)

    \ \ \ \ \ (make-pair-hash car-comparator cdr-comparator)))

    \;
  </scm-chunk>

  <paragraph|make-list-comparator><index|make-list-comparator>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    ;; Cheap test for listness

    (define (norp? obj) (or (null? obj) (pair? obj)))

    \;

    (define (make-list-comparator element-comparator type-test empty? head tail)

    \ \ \ (make-comparator

    \ \ \ \ \ (make-list-type-test element-comparator type-test empty? head tail)

    \ \ \ \ \ (make-list=? element-comparator type-test empty? head tail)

    \ \ \ \ \ (make-list\<less\>? element-comparator type-test empty? head tail)

    \ \ \ \ \ (make-list-hash element-comparator type-test empty? head tail)))

    \;

    (define (make-list-type-test element-comparator type-test empty? head tail)

    \ \ (lambda (obj)

    \ \ \ \ (and

    \ \ \ \ \ \ (type-test obj)

    \ \ \ \ \ \ (let ((elem-type-test (comparator-type-test-predicate element-comparator)))

    \ \ \ \ \ \ \ \ (let loop ((obj obj))

    \ \ \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ \ \ ((empty? obj) #t)

    \ \ \ \ \ \ \ \ \ \ \ \ ((not (elem-type-test (head obj))) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (tail obj)))))))))

    \;

    (define (make-list=? element-comparator type-test empty? head tail)

    \ \ (lambda (a b)

    \ \ \ \ (let ((elem=? (comparator-equality-predicate element-comparator)))

    \ \ \ \ \ \ (let loop ((a a) (b b))

    \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ ((and (empty? a) (empty? b) #t))

    \ \ \ \ \ \ \ \ \ \ ((empty? a) #f)

    \ \ \ \ \ \ \ \ \ \ ((empty? b) #f)

    \ \ \ \ \ \ \ \ \ \ ((elem=? (head a) (head b)) (loop (tail a) (tail b)))

    \ \ \ \ \ \ \ \ \ \ (else #f))))))

    \;

    (define (make-list\<less\>? element-comparator type-test empty? head tail)

    \ \ (lambda (a b)

    \ \ \ \ (let ((elem=? (comparator-equality-predicate element-comparator))

    \ \ \ \ \ \ \ \ \ \ (elem\<less\>? (comparator-ordering-predicate element-comparator)))

    \ \ \ \ \ \ (let loop ((a a) (b b))

    \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ ((and (empty? a) (empty? b) #f))

    \ \ \ \ \ \ \ \ \ \ ((empty? a) #t)

    \ \ \ \ \ \ \ \ \ \ ((empty? b) #f)

    \ \ \ \ \ \ \ \ \ \ ((elem=? (head a) (head b)) (loop (tail a) (tail b)))

    \ \ \ \ \ \ \ \ \ \ ((elem\<less\>? (head a) (head b)) #t)

    \ \ \ \ \ \ \ \ \ \ (else #f))))))

    \;

    (define (make-list-hash element-comparator type-test empty? head tail)

    \ \ (lambda (obj)

    \ \ \ \ (let ((elem-hash (comparator-hash-function element-comparator))

    \ \ \ \ \ \ \ \ \ \ (acc (make-hasher)))

    \ \ \ \ \ \ (let loop ((obj obj))

    \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ ((empty? obj) (acc))

    \ \ \ \ \ \ \ \ \ \ (else (acc (elem-hash (head obj))) (loop (tail obj))))))))

    \;
  </scm-chunk>

  \;

  <paragraph|make-vector-comparator><index|make-vector-comparator>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (make-vector-comparator element-comparator type-test length ref)

    \ \ (make-comparator

    \ \ \ \ (make-vector-type-test element-comparator type-test length ref)

    \ \ \ \ (make-vector=? element-comparator type-test length ref)

    \ \ \ \ (make-vector\<less\>? element-comparator type-test length ref)

    \ \ \ \ (make-vector-hash element-comparator type-test length ref)))

    \;

    (define (make-vector-type-test element-comparator type-test length ref)

    \ \ (lambda (obj)

    \ \ \ \ (and

    \ \ \ \ \ \ (type-test obj)

    \ \ \ \ \ \ (let ((elem-type-test (comparator-type-test-predicate element-comparator))

    \ \ \ \ \ \ \ \ \ \ \ \ (len (length obj)))

    \ \ \ \ \ \ \ \ (let loop ((n 0))

    \ \ \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ \ \ ((= n len) #t)

    \ \ \ \ \ \ \ \ \ \ \ \ ((not (elem-type-test (ref obj n))) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ (else (loop (+ n 1)))))))))

    \;

    (define (make-vector=? element-comparator type-test length ref)

    \ \ \ (lambda (a b)

    \ \ \ \ \ (and

    \ \ \ \ \ \ \ (= (length a) (length b))

    \ \ \ \ \ \ \ (let ((elem=? (comparator-equality-predicate element-comparator))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (len (length b)))

    \ \ \ \ \ \ \ \ \ (let loop ((n 0))

    \ \ \ \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ \ \ \ ((= n len) #t)

    \ \ \ \ \ \ \ \ \ \ \ \ \ ((elem=? (ref a n) (ref b n)) (loop (+ n 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (else #f)))))))

    \;

    (define (make-vector\<less\>? element-comparator type-test length ref)

    \ \ \ (lambda (a b)

    \ \ \ \ \ (cond

    \ \ \ \ \ \ \ ((\<less\> (length a) (length b)) #t)

    \ \ \ \ \ \ \ ((\<gtr\> (length a) (length b)) #f)

    \ \ \ \ \ \ \ \ (else

    \ \ \ \ \ \ \ \ \ (let ((elem=? (comparator-equality-predicate element-comparator))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (elem\<less\>? (comparator-ordering-predicate element-comparator))

    \ \ \ \ \ \ \ \ \ \ \ \ \ (len (length a)))

    \ \ \ \ \ \ \ \ \ (let loop ((n 0))

    \ \ \ \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ \ \ \ ((= n len) #f)

    \ \ \ \ \ \ \ \ \ \ \ \ \ ((elem=? (ref a n) (ref b n)) (loop (+ n 1)))

    \ \ \ \ \ \ \ \ \ \ \ \ \ ((elem\<less\>? (ref a n) (ref b n)) #t)

    \ \ \ \ \ \ \ \ \ \ \ \ \ (else #f))))))))

    \;

    (define (make-vector-hash element-comparator type-test length ref)

    \ \ (lambda (obj)

    \ \ \ \ (let ((elem-hash (comparator-hash-function element-comparator))

    \ \ \ \ \ \ \ \ \ \ (acc (make-hasher))

    \ \ \ \ \ \ \ \ \ \ (len (length obj)))

    \ \ \ \ \ \ (let loop ((n 0))

    \ \ \ \ \ \ \ \ (cond

    \ \ \ \ \ \ \ \ \ \ ((= n len) (acc))

    \ \ \ \ \ \ \ \ \ \ (else (acc (elem-hash (ref obj n))) (loop (+ n 1))))))))

    \;
  </scm-chunk>

  <section|标准函数>

  <paragraph|object-type>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (object-type obj)

    \ \ (cond

    \ \ \ \ ((null? obj) 0)

    \ \ \ \ ((pair? obj) 1)

    \ \ \ \ ((boolean? obj) 2)

    \ \ \ \ ((char? obj) 3)

    \ \ \ \ ((string? obj) 4)

    \ \ \ \ ((symbol? obj) 5)

    \ \ \ \ ((number? obj) 6)

    \ \ \ \ ((vector? obj) 7)

    \ \ \ \ ((bytevector? obj) 8)

    \ \ \ \ (else 65535)))

    \;
  </scm-chunk>

  <paragraph|boolean\<less\>?><index|boolean\<less\>?>

  <\scm-chunk|tests/goldfish/liii/comparator-test.scm|true|true>
    (define boolean-comparator

    \ \ (make-comparator boolean? eq? boolean\<less\>? default-hash))

    \;

    (check-false (boolean\<less\>? #t #t))

    (check-false (\<less\>? boolean-comparator #t #t))

    (check-false (boolean\<less\>? #f #f))

    (check-false (\<less\>? boolean-comparator #f #f))

    (check-true (boolean\<less\>? #f #t))

    (check-true (\<less\>? boolean-comparator #f #t))

    (check-false (boolean\<less\>? #t #f))

    (check-false (\<less\>? boolean-comparator #t #f))

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (boolean\<less\>? a b)

    \ \ ;; #f \<less\> #t but not otherwise

    \ \ (and (not a) b))

    \;
  </scm-chunk>

  <paragraph|complex\<less\>?>

  <subparagraph|测试>

  <\scm-chunk|tests/goldfish/liii/comparator-test.scm|true|true>
    (check-false (complex\<less\>? 1 1))

    (check-true (complex\<less\>? 0+1i 0+2i))

    (check-true (complex\<less\>? 1+2i 2+2i))

    \;
  </scm-chunk>

  <subparagraph|实现>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (complex\<less\>? a b)

    \ \ (if (= (real-part a) (real-part b))

    \ \ \ \ (\<less\> (imag-part a) (imag-part b))

    \ \ \ \ (\<less\> (real-part a) (real-part b))))

    \;
  </scm-chunk>

  <paragraph|symbol\<less\>?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (symbol\<less\>? a b)

    \ \ (string\<less\>? (symbol-\<gtr\>string a) (symbol-\<gtr\>string b)))

    \;
  </scm-chunk>

  \;

  <paragraph|default-hash><index|default-hash>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (default-hash obj)

    \ \ (hash-code obj))

    \;
  </scm-chunk>

  <paragraph|default-ordering>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (dispatch-ordering type a b)

    \ \ (case type

    \ \ \ \ ((0) 0) ; All empty lists are equal

    \ \ \ \ ((1) ((make-pair\<less\>? (make-default-comparator) (make-default-comparator)) a b))

    \ \ \ \ ((2) (boolean\<less\>? a b))

    \ \ \ \ ((3) (char\<less\>? a b))

    \ \ \ \ ((4) (string\<less\>? a b))

    \ \ \ \ ((5) (symbol\<less\>? a b))

    \ \ \ \ ((6) (complex\<less\>? a b))

    \ \ \ \ ((7) ((make-vector\<less\>? (make-default-comparator) vector? vector-length vector-ref)

    \ \ \ \ \ \ \ \ \ \ a b))

    \ \ \ \ ((8) ((make-vector\<less\>? (make-comparator exact-integer? = \<less\> default-hash)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bytevector? bytevector-length bytevector-u8-ref)

    \ \ \ \ \ \ \ \ \ \ a b))

    \ \ \ \ ; Add more here

    \ \ \ \ (else (binary\<less\>? (registered-comparator type) a b))))

    \;

    (define (default-ordering a b)

    \ \ (let ((a-type (object-type a))

    \ \ \ \ \ \ \ \ (b-type (object-type b)))

    \ \ \ \ (cond

    \ \ \ \ \ \ ((\<less\> a-type b-type) #t)

    \ \ \ \ \ \ ((\<gtr\> a-type b-type) #f)

    \ \ \ \ \ \ (else (dispatch-ordering a-type a b)))))

    \;
  </scm-chunk>

  <paragraph|default-equality>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (dispatch-equality type a b)

    \ \ (case type

    \ \ \ \ ((0) #t) ; All empty lists are equal

    \ \ \ \ ((1) ((make-pair=? (make-default-comparator) (make-default-comparator)) a b))

    \ \ \ \ ((2) (boolean=? a b))

    \ \ \ \ ((3) (char=? a b))

    \ \ \ \ ((4) (string=? a b))

    \ \ \ \ ((5) (symbol=? a b))

    \ \ \ \ ((6) (= a b))

    \ \ \ \ ((7) ((make-vector=? (make-default-comparator)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ vector? vector-length vector-ref) a b))

    \ \ \ \ ((8) ((make-vector=? (make-comparator exact-integer? = \<less\> default-hash)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bytevector? bytevector-length bytevector-u8-ref) a b))

    \ \ \ \ ; Add more here

    \ \ \ \ (else (binary=? (registered-comparator type) a b))))

    \;

    (define (default-equality a b)

    \ \ (let ((a-type (object-type a))

    \ \ \ \ \ \ \ \ (b-type (object-type b)))

    \ \ \ \ (if (= a-type b-type)

    \ \ \ \ \ \ \ \ (dispatch-equality a-type a b)

    \ \ \ \ \ \ \ \ #f)))

    \;
  </scm-chunk>

  <paragraph|make-default-comparator>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (make-default-comparator)

    \ \ (make-comparator

    \ \ \ \ (lambda (obj) #t)

    \ \ \ \ default-equality

    \ \ \ \ default-ordering

    \ \ \ \ default-hash))

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/comparator-test.scm|true|true>
    (let1 default-comp (make-default-comparator)

    \ \ (check-true (\<less\>? default-comp #f #t))

    \ \ (check-true (\<less\>? default-comp (cons #f #f) (cons #t #t)))

    \ \ (check-true (\<less\>? default-comp (list 1 2) (list 2 3)))

    \ \ (check-true (\<less\>? default-comp (list 1 2) (list 1 3)))

    )

    \;
  </scm-chunk>

  <section|比较谓词>

  <paragraph|=?><index|=?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (=? comparator a b . objs)

    \ \ (let loop ((a a) (b b) (objs objs))

    \ \ \ \ (and (binary=? comparator a b)

    \ \ \ \ \ \ \ \ \ (if (null? objs) #t (loop b (car objs) (cdr objs))))))

    \;
  </scm-chunk>

  \;

  <paragraph|\<less\>?><index|\<less\>?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (\<less\>? comparator a b . objs)

    \ \ (let loop ((a a) (b b) (objs objs))

    \ \ \ \ (and (binary\<less\>? comparator a b)

    \ \ \ \ \ \ \ \ \ (if (null? objs) #t (loop b (car objs) (cdr objs))))))

    \;
  </scm-chunk>

  \;

  <paragraph|\<gtr\>?><index|\<gtr\>?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (\<gtr\>? comparator a b . objs)

    \ \ (let loop ((a a) (b b) (objs objs))

    \ \ \ \ (and (binary\<gtr\>? comparator a b)

    \ \ \ \ \ \ \ \ \ (if (null? objs) #t (loop b (car objs) (cdr objs))))))

    \;
  </scm-chunk>

  \;

  <paragraph|\<less\>=?><index|\<less\>=?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (\<less\>=? comparator a b . objs)

    \ \ (let loop ((a a) (b b) (objs objs))

    \ \ \ \ (and (binary\<less\>=? comparator a b)

    \ \ \ \ \ \ \ \ \ (if (null? objs) #t (loop b (car objs) (cdr objs))))))

    \;
  </scm-chunk>

  \;

  <paragraph|\<gtr\>=?><index|\<gtr\>=?>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|true>
    (define (\<gtr\>=? comparator a b . objs)

    \ \ (let loop ((a a) (b b) (objs objs))

    \ \ \ \ (and (binary\<gtr\>=? comparator a b)

    \ \ \ \ \ \ \ \ \ (if (null? objs) #t (loop b (car objs) (cdr objs))))))

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/srfi/srfi-128.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/liii/comparator-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(liii set)>

  <section|许可证>

  <\scm-chunk|goldfish/liii/set.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-113.scm|false|true>
    ; Copyright (C) John Cowan (2015). All Rights Reserved.

    ;

    ; Permission is hereby granted, free of charge, to any person obtaining a copy of

    ; this software and associated documentation files (the "Software"), to deal in

    ; the Software without restriction, including without limitation the rights to

    ; use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies

    ; of the Software, and to permit persons to whom the Software is furnished to do

    ; so, subject to the following conditions:

    ;

    ; The above copyright notice and this permission notice shall be included in all

    ; copies or substantial portions of the Software.

    ;

    ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR

    ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,

    ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE

    ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER

    ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,

    ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

    ; SOFTWARE.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/liii/set.scm|true|true>
    (define-library (liii set)

    (import (srfi srfi-113))

    (export set?)

    (begin

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-113.scm|true|true>
    (define-library (srfi srfi-113)

    (import (scheme base))

    (export set?)

    (begin

    \;
  </scm-chunk>

  \;

  <section|结尾>

  <\scm-chunk|goldfish/liii/set.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/srfi-113.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  \;

  <chapter|三鲤扩展库>

  <section|结尾>

  <\scm-chunk|goldfish/scheme/base.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <chapter|(scheme case-lambda)>

  <section|协议>

  <\scm-chunk|tests/goldfish/scheme/case-lambda-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  在Scheme语言中，<scm|case-lambda>是一种特殊的lambda表达式，它可以根据不同数量的参数执行不同的代码块。<scm|case-lambda>允许你定义一个函数，这个函数根据传入参数的数量来选择执行不同的lambda表达式。

  \;

  下面是一个使用<scm|case-lambda>的示例：

  <\scm-chunk|tests/goldfish/scheme/case-lambda-test.scm|true|false>
    (import (liii list)

    \ \ \ \ \ \ \ \ (liii check)

    \ \ \ \ \ \ \ \ (scheme case-lambda))

    \;

    (check-set-mode! 'report-failed)

    \;

    (define (my-func . args)

    \ \ (case-lambda

    \ \ \ \ (() "zero args")

    \ \ \ \ ((x) (+ x x))

    \ \ \ \ ((x y) (+ x y))

    \ \ \ \ ((x y . rest) (reduce + 0 (cons x (cons y rest))))))

    \;

    (check ((my-func)) =\<gtr\> "zero args")

    (check ((my-func) 2) =\<gtr\> 4)

    (check ((my-func) 3 4) =\<gtr\> 7)

    (check ((my-func) 1 2 3 4) =\<gtr\> 10)

    \;

    (check-report)

    \;
  </scm-chunk>

  <section|实现>

  <\scm-chunk|goldfish/scheme/case-lambda.scm|false|false>
    ; 0-clause BSD

    ; Bill Schottstaedt

    ; from S7 source repo: r7rs.scm

    \;

    (define-library (scheme case-lambda)

    (export case-lambda)

    (begin

    \;

    ;; case-lambda \ \ \ \ \ \ 

    (define-macro (case-lambda . choices)

    \ \ ‘(lambda args

    \ \ \ \ \ (case (length args)

    \ \ \ \ \ \ \ ,@(map (lambda (choice)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (if (or (symbol? (car choice))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (negative? (length (car choice))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ‘(else (apply (lambda ,(car choice) ,@(cdr choice)) args))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ‘((,(length (car choice)))\ 

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (apply (lambda ,(car choice) ,@(cdr choice)) args))))

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ choices))))

    \;

    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <chapter|(scheme char)>

  <section|许可证>

  <\scm-chunk|tests/goldfish/scheme/char-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|tests/goldfish/scheme/char-test.scm|true|true>
    (import (liii check))

    \;

    (check-set-mode! 'report-failed)

    \;
  </scm-chunk>

  <section|实现>

  <label|r7rs><paragraph|char-upcase><index|char-upcase>

  S7内置函数。

  <\scm-chunk|tests/goldfish/scheme/char-test.scm|true|true>
    (check (char-upcase #\\A) =\<gtr\> #\\A)

    (check (char-upcase #\\a) =\<gtr\> #\\A)

    (check (char-upcase #\\?) =\<gtr\> #\\?)

    (check (char-upcase #\\$) =\<gtr\> #\\$)

    (check (char-upcase #\\.) =\<gtr\> #\\.)

    (check (char-upcase #\\\\) =\<gtr\> #\\\\)

    (check (char-upcase #\\5) =\<gtr\> #\\5)

    (check (char-upcase #\\)) =\<gtr\> #\\))

    (check (char-upcase #\\%) =\<gtr\> #\\%)

    (check (char-upcase #\\0) =\<gtr\> #\\0)

    (check (char-upcase #\\_) =\<gtr\> #\\_)

    (check (char-upcase #\\?) =\<gtr\> #\\?)

    (check (char-upcase #\\space) =\<gtr\> #\\space)

    (check (char-upcase #\\newline) =\<gtr\> #\\newline)

    (check (char-upcase #\\null) =\<gtr\> #\\null)

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|tests/goldfish/scheme/char-test.scm|true|false>
    (check-report)

    \;
  </scm-chunk>

  <chapter|(scheme file)>

  <section|许可证>

  <\scm-chunk|goldfish/scheme/file.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/scheme/file.scm|true|true>
    (define-library (scheme file)

    (export open-binary-input-file open-binary-output-file)

    (begin

    \ \ 
  </scm-chunk>

  <section|实现>

  <label|r7rs><paragraph|open-input-file><index|open-input-file>

  S7内置函数。

  <label|r7rs><paragraph|open-binary-input-file><index|open-binary-input-file>

  <\scm-chunk|goldfish/scheme/file.scm|true|true>
    (define open-binary-input-file open-input-file)

    \;
  </scm-chunk>

  \;

  <label|r7rs><paragraph|open-output-file><index|open-output-file>

  S7内置函数。

  <label|r7rs><paragraph|open-binary-output-file><index|open-binary-output-file>

  <\scm-chunk|goldfish/scheme/file.scm|true|true>
    (define open-binary-output-file open-output-file)

    \;
  </scm-chunk>

  <section|结尾>

  <\scm-chunk|goldfish/scheme/file.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <chapter|(srfi srfi-8)>

  \;

  官网：<slink|https://srfi.schemers.org/srfi-8/srfi-8.html>

  官网的参考实现是：

  <\scm-code>
    (define-syntax receive

    \ \ (syntax-rules ()

    \ \ \ \ ((receive formals expression body ...)

    \ \ \ \ \ (call-with-values (lambda () expression)

    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (lambda formals body ...)))))
  </scm-code>

  但是S7 Scheme里面没有define-syntax和syntax-rule，在墨干中的实现是这样的：

  <\session|goldfish|default>
    <\unfolded-io>
      \<gtr\>\ 
    <|unfolded-io>
      (define-macro (receive vars vals . body)

      \ \ ‘((lambda ,vars ,@body) ,vals)) ; GPL
    <|unfolded-io>
      receive
    </unfolded-io>

    <\unfolded-io>
      \<gtr\>\ 
    <|unfolded-io>
      (receive (a b) (values 1 2) (+ a b))
    <|unfolded-io>
      3
    </unfolded-io>

    <\unfolded-io>
      \<gtr\>\ 
    <|unfolded-io>
      ((lambda (a b) (+ a b)) 1 2)
    <|unfolded-io>
      3
    </unfolded-io>

    <\input>
      \<gtr\>\ 
    <|input>
      \;
    </input>
  </session>

  S7里面有<scm|call-with-values>，使用<scm|define-macro>就可以实现SRFI-8。

  <\scm-chunk|goldfish/srfi/srfi-8.scm|false|false>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;

    (define-library (srfi srfi-8)

    (export receive) \ \ \ \ \ \ \ \ \ \ \ \ \ 

    (begin

    \;

    (define-macro (receive formals expression . body)

    \ \ ‘(call-with-values

    \ \ \ \ (lambda () (values ,expression))

    \ \ \ \ (lambda ,formals ,@body)))

    \;

    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  \;

  <\scm-chunk|tests/goldfish/srfi/srfi-8-test.scm|false|false>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;

    (import (srfi srfi-8)

    \ \ \ \ \ \ \ \ (liii check))

    \;

    (check-set-mode! 'report-failed)

    \;

    (check

    \ \ (receive (a b) (values 1 2) (+ a b))

    \ \ =\<gtr\>

    \ \ 3)

    \;

    (check-report)

    \;
  </scm-chunk>

  <chapter|(srfi sicp)>

  <section|许可证>

  <\scm-chunk|goldfish/srfi/srfi-216.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/sicp.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <\scm-chunk|tests/goldfish/srfi/sicp-test.scm|false|true>
    ;

    ; Copyright (C) 2024 The Goldfish Scheme Authors

    ;

    ; Licensed under the Apache License, Version 2.0 (the "License");

    ; you may not use this file except in compliance with the License.

    ; You may obtain a copy of the License at

    ;

    ; http://www.apache.org/licenses/LICENSE-2.0

    ;

    ; Unless required by applicable law or agreed to in writing, software

    ; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT

    ; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the

    ; License for the specific language governing permissions and limitations

    ; under the License.

    ;

    \;
  </scm-chunk>

  <section|接口>

  <\scm-chunk|goldfish/srfi/srfi-216.scm|true|true>
    (define-library (srfi srfi-216)

    (export true false nil runtime)

    (import (scheme time))

    (begin

    \;
  </scm-chunk>

  <\scm-chunk|goldfish/srfi/sicp.scm|true|false>
    (define-library (srfi sicp)

    (export true false nil runtime)

    (import (srfi srfi-216)))

    \;
  </scm-chunk>

  <section|测试>

  <\scm-chunk|tests/goldfish/srfi/sicp-test.scm|true|false>
    (import (srfi sicp)

    \ \ \ \ \ \ \ \ (liii os)

    \ \ \ \ \ \ \ \ (liii check))

    \;

    (display (runtime))

    (newline)

    \;

    (when (os-linux?)

    \ \ (os-call "sleep 0.01"))

    \;

    (display (runtime))

    (newline)

    \;

    (check-true true)

    (check-false false)

    (check-true (null? nil))

    \;

    (check-report)

    \;
  </scm-chunk>

  <section|实现>

  <\scm-chunk|goldfish/srfi/srfi-216.scm|true|true>
    (define true #t)

    \;

    (define false #f)

    \;

    (define nil '())

    \;

    (define (runtime)

    \ \ (round (* 1000 (current-second))))

    \;
  </scm-chunk>

  \;

  <section|结尾>

  <\scm-chunk|goldfish/srfi/srfi-216.scm|true|false>
    ) ; end of begin

    ) ; end of define-library

    \;
  </scm-chunk>

  <\the-index|idx>
    <index+1|!=|<pageref|auto-96>>

    <index+1|==|<pageref|auto-94>>

    <index+1|???|<pageref|auto-132>>

    <index+1|any|<pageref|auto-347>>

    <index+1|append|<pageref|auto-308>>

    <index+1|apply|<pageref|auto-35>>

    <index+1|binary-port?|<pageref|auto-62>>

    <index+1|caar|<pageref|auto-269>>

    <index+1|call-with-port|<pageref|auto-52>>

    <index+1|car|<pageref|auto-265>>

    <index+1|case|<pageref|auto-9>>

    <index+1|cdr|<pageref|auto-267>>

    <index+1|char?|<pageref|auto-25>>

    <index+1|char=?|<pageref|auto-27>>

    <index+1|check|<pageref|auto-143>>

    <index+1|check-catch|<pageref|auto-149>>

    <index+1|check-failed?|<pageref|auto-141>>

    <index+1|check-false|<pageref|auto-147>>

    <index+1|check-report|<pageref|auto-153>>

    <index+1|check-set-mode!|<pageref|auto-139>>

    <index+1|check-true|<pageref|auto-145>>

    <index+1|circular-list|<pageref|auto-251>>

    <index+1|circular-list?|<pageref|auto-260>>

    <index+1|close-input-port|<pageref|auto-70>>

    <index+1|close-output-port|<pageref|auto-72>>

    <index+1|close-port|<pageref|auto-68>>

    <index+1|compose|<pageref|auto-106>>

    <index+1|cons|<pageref|auto-245>>

    <index+1|count|<pageref|auto-310>>

    <index+1|define-record-type|<pageref|auto-14>>

    <index+1|delete|<pageref|auto-352>>

    <index+1|delete-duplicates|<pageref|auto-354>>

    <index+1|display*|<pageref|auto-98>>

    <index+1|drop|<pageref|auto-295>>

    <index+1|drop-right|<pageref|auto-299>>

    <index+1|drop-while|<pageref|auto-343>>

    <index+1|eighth|<pageref|auto-287>>

    <index+1|eof-object|<pageref|auto-80>>

    <index+1|every|<pageref|auto-349>>

    <index+1|fifth|<pageref|auto-281>>

    <index+1|file-error?|<pageref|auto-48>>

    <index+1|file-exists-error|<pageref|auto-124>>

    <index+1|file-not-found-error|<pageref|auto-120>>

    <index+1|filter|<pageref|auto-326>>

    <index+1|find|<pageref|auto-339>>

    <index+1|first|<pageref|auto-273>>

    <index+1|flatmap|<pageref|auto-363>>

    <index+1|fold|<pageref|auto-317>>

    <index+1|fold-right|<pageref|auto-319>>

    <index+1|for-each|<pageref|auto-315>>

    <index+1|fourth|<pageref|auto-279>>

    <index+1|guard|<pageref|auto-44>>

    <index+1|hash-table?|<pageref|auto-496>>

    <index+1|hash-table=?|<pageref|auto-506>>

    <index+1|hash-table-clear!|<pageref|auto-530>>

    <index+1|hash-table-contains?|<pageref|auto-498>>

    <index+1|hash-table-delete!|<pageref|auto-522>>

    <index+1|hash-table-empty?|<pageref|auto-502>>

    <index+1|hash-table-\<gtr\>alist|<pageref|auto-548>>

    <index+1|hash-table-keys|<pageref|auto-539>>

    <index+1|hash-table-ref|<pageref|auto-511>>

    <index+1|hash-table-ref/default|<pageref|auto-513>>

    <index+1|hash-table-set!|<pageref|auto-518>>

    <index+1|hash-table-size|<pageref|auto-535>>

    <index+1|hash-table-update!|<pageref|auto-526>>

    <index+1|hash-table-values|<pageref|auto-543>>

    <index+1|identity|<pageref|auto-104>>

    <index+1|in?|<pageref|auto-100>>

    <index+1|input-port?|<pageref|auto-54>>

    <index+1|input-port-open?|<pageref|auto-64>>

    <index+1|iota|<pageref|auto-253>>

    <index+1|last|<pageref|auto-303>>

    <index+1|last-pair|<pageref|auto-301>>

    <index+1|length|<pageref|auto-306>>

    <index+1|length=?|<pageref|auto-357>>

    <index+1|let1|<pageref|auto-102>>

    <index+1|let-values|<pageref|auto-11>>

    <index+1|list|<pageref|auto-247>>

    <index+1|list-\<gtr\>string|<pageref|auto-167>>

    <index+1|list-\<gtr\>vector|<pageref|auto-436>>

    <index+1|list-index|<pageref|auto-345>>

    <index+1|list-not-null?|<pageref|auto-369>>

    <index+1|list-ref|<pageref|auto-271>>

    <index+1|list-view|<pageref|auto-359>>

    <index+1|make-list|<pageref|auto-249>>

    <index+1|make-vector|<pageref|auto-378>>

    <index+1|map|<pageref|auto-313>>

    <index+1|member|<pageref|auto-337>>

    <index+1|memq|<pageref|auto-333>>

    <index+1|memv|<pageref|auto-335>>

    <index+1|ninth|<pageref|auto-289>>

    <index+1|not-a-directory-error|<pageref|auto-122>>

    <index+1|not-null-list?|<pageref|auto-365>>

    <index+1|null?|<pageref|auto-258>>

    <index+1|null-list?|<pageref|auto-262>>

    <index+1|os-error|<pageref|auto-118>>

    <index+1|output-port?|<pageref|auto-56>>

    <index+1|output-port-open?|<pageref|auto-66>>

    <index+1|pair?|<pageref|auto-256>>

    <index+1|partition|<pageref|auto-328>>

    <index+1|port?|<pageref|auto-58>>

    <index+1|procedure?|<pageref|auto-33>>

    <index+1|queue|<pageref|auto-468>>

    <index+1|queue-back|<pageref|auto-476>>

    <index+1|queue-empty?|<pageref|auto-470>>

    <index+1|queue-front|<pageref|auto-474>>

    <index+1|queue-\<gtr\>list|<pageref|auto-482>>

    <index+1|queue-pop!|<pageref|auto-480>>

    <index+1|queue-push!|<pageref|auto-478>>

    <index+1|queue-size|<pageref|auto-472>>

    <index+1|read-error?|<pageref|auto-46>>

    <index+1|reduce|<pageref|auto-321>>

    <index+1|reduce-right|<pageref|auto-323>>

    <index+1|remove|<pageref|auto-330>>

    <index+1|second|<pageref|auto-275>>

    <index+1|seventh|<pageref|auto-285>>

    <index+1|sixth|<pageref|auto-283>>

    <index+1|square|<pageref|auto-21>>

    <index+1|stack|<pageref|auto-448>>

    <index+1|stack-empty?|<pageref|auto-450>>

    <index+1|stack-\<gtr\>list|<pageref|auto-460>>

    <index+1|stack-pop!|<pageref|auto-458>>

    <index+1|stack-push!|<pageref|auto-456>>

    <index+1|stack-size|<pageref|auto-452>>

    <index+1|stack-top|<pageref|auto-454>>

    <index+1|string?|<pageref|auto-162>>

    <index+1|string-any|<pageref|auto-178>>

    <index+1|string-append|<pageref|auto-224>>

    <index+1|string-contains|<pageref|auto-217>>

    <index+1|string-copy|<pageref|auto-185>>

    <index+1|string-count|<pageref|auto-219>>

    <index+1|string-drop|<pageref|auto-192>>

    <index+1|string-drop-right|<pageref|auto-194>>

    <index+1|string-every|<pageref|auto-176>>

    <index+1|string-for-each|<pageref|auto-231>>

    <index+1|string-\<gtr\>list|<pageref|auto-165>>

    <index+1|string-\<gtr\>vector|<pageref|auto-440>>

    <index+1|string-index|<pageref|auto-213>>

    <index+1|string-index-right|<pageref|auto-215>>

    <index+1|string-join|<pageref|auto-169>>

    <index+1|string-length|<pageref|auto-181>>

    <index+1|string-map|<pageref|auto-227>>

    <index+1|string-null?|<pageref|auto-174>>

    <index+1|string-pad|<pageref|auto-196>>

    <index+1|string-pad-right|<pageref|auto-198>>

    <index+1|string-prefix?|<pageref|auto-208>>

    <index+1|string-ref|<pageref|auto-183>>

    <index+1|string-reverse|<pageref|auto-222>>

    <index+1|string-suffix?|<pageref|auto-210>>

    <index+1|string-take|<pageref|auto-188>>

    <index+1|string-take-right|<pageref|auto-190>>

    <index+1|string-tokenize|<pageref|auto-234>>

    <index+1|string-trim|<pageref|auto-201>>

    <index+1|string-trim-both|<pageref|auto-205>>

    <index+1|string-trim-right|<pageref|auto-203>>

    <index+1|take|<pageref|auto-293>>

    <index+1|take-right|<pageref|auto-297>>

    <index+1|take-while|<pageref|auto-341>>

    <index+1|tenth|<pageref|auto-291>>

    <index+1|test|<pageref|auto-151>>

    <index+1|textual-port?|<pageref|auto-60>>

    <index+1|third|<pageref|auto-277>>

    <index+1|timeout-error|<pageref|auto-126>>

    <index+1|typed-lambda|<pageref|auto-108>>

    <index+1|type-error|<pageref|auto-128>>

    <index+1|value-error|<pageref|auto-130>>

    <index+1|vector|<pageref|auto-380>>

    <index+1|vector?|<pageref|auto-390>>

    <index+1|vector-any|<pageref|auto-412>>

    <index+1|vector-append|<pageref|auto-387>>

    <index+1|vector-copy|<pageref|auto-384>>

    <index+1|vector-copy!|<pageref|auto-431>>

    <index+1|vector-count|<pageref|auto-407>>

    <index+1|vector-empty?|<pageref|auto-392>>

    <index+1|vector-every|<pageref|auto-416>>

    <index+1|vector-fill!|<pageref|auto-429>>

    <index+1|vector-for-each|<pageref|auto-403>>

    <index+1|vector-\<gtr\>list|<pageref|auto-434>>

    <index+1|vector-\<gtr\>string|<pageref|auto-438>>

    <index+1|vector-index|<pageref|auto-418>>

    <index+1|vector-index-right|<pageref|auto-420>>

    <index+1|vector-length|<pageref|auto-396>>

    <index+1|vector-map|<pageref|auto-401>>

    <index+1|vector-partition|<pageref|auto-422>>

    <index+1|vector-ref|<pageref|auto-398>>

    <index+1|vector-set!|<pageref|auto-425>>

    <index+1|vector-swap!|<pageref|auto-427>>
  </the-index>
</body>

<\initial>
  <\collection>
    <associate|font-base-size|8>
    <associate|info-flag|paper>
    <associate|page-height|auto>
    <associate|page-medium|papyrus>
    <associate|page-screen-margin|false>
    <associate|page-type|a5>
    <associate|page-width|auto>
    <associate|save-aux|false>
  </collection>
</initial>
